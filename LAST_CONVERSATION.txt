USER:
Is my hypothesis correct, that if I give an LLM an MCP to a sandbox where they can render shaders, that that interactive REPL will produce better outcomes?

AGENT:
CreatePlan



**Codebase Search Results:**

- **/Users/erichowens/coding/metal-shader-mcp/DESIGN.md**
```
# UI/UX Design: Shader REPL App (macOS/iOS)

This document outlines the user stories, wireframes, view hierarchy, persistence model, and milestones for the local SwiftUI app that showcases MCP-driven shader development.

## 1) User Purpose & Stories

- As a shader artist, I want to write/iterate on a shader and immediately see the visual result so I can guide Claude toward the intended look.
- As a developer, I want a REPL loop with deterministic controls (time/seed/resolution) so I can reproduce and debug issues.
- As a learner, I want a rich shader library with educational annotations and presets so I can study, remix, and understand techniques.
- As a collaborator, I want to track generational improvements (snapshots/variants) across a project so I can show progress and avoid regressions.
- As a power user, I want to browse and trigger MCP tools, see their schemas, and run them with arguments from within the app.

## 2) Information Architecture / Screens

Primary Tabs (left sidebar or top tab bar):
- REPL
- Library
- Projects
- MCP Tools
- History

### REPL Screen (default)
Layout (3 columns):
- Left Pane: MCP Tool Explorer (collapsible)
  - Tools list (search/filter)
  - Tool detail: description + JSON schema + quick-run form
  - Recent tool calls & responses
- Center Pane: Canvas + Timeline
  - Render view (MTKView) with overlays (UV grid, centerlines, gamut warn, safe area)
  - Playback controls: Play/Pause, Speed, Time scrubber
  - Device/Resolution selector, Seed control
  - Performance HUD: fps, gpu_ms, cpu_ms
- Right Pane: Editor & Inspector
  - Code editor (Metal) with syntax highlighting & inline errors
  - Errors panel (list with line jump)
  - Uniforms panel (auto-generated controls: sliders/fields/vec pickers)
  - Export controls: Screenshot/Sequence

### Library Screen
- Grid of Educational Shaders (thumbnail + title + tags)
- Filters: category (generative, image fx, animation, 3D), difficulty, performance
- Detail Drawer:
  - Code, Description, Annotations (educational notes), References
  - Presets (thumbnails), ‚ÄúOpen in REPL‚Äù button

### Projects Screen
- List of projects with progress metrics
- Project detail: Snapshots (timeline), Variants (branches), Notes
- ‚ÄúCompare‚Äù mode: select two snapshots/variants ‚Üí diptych/triptych export

### MCP Tools Screen
- Full-screen tool browser
- Each tool shows: name, description, schema, examples, run form, result log

### History Screen
- Chronological log of edits: code changes, tool calls, screenshots
- Quick diff: before/after code, baseline/actual visuals

## 3) View Hierarchy (SwiftUI)
- App
  - NavigationSplitView (Sidebar: Tabs; Content: selected screen)
    - REPLView
      - HStack { ToolExplorerView | CanvasView | EditorInspectorView }
    - LibraryView (LazyVGrid of ShaderCardView)
    - ProjectsView ‚Üí ProjectDetailView (SnapshotsView, VariantsView)
    - MCPToolsView (ToolList ‚Üí ToolDetail)
    - HistoryView (Timeline + Detail)

## 4) Persistence Model (JSON)
Paths under Resources/:
- communication/  (MCP bridge files)
- screenshots/
- projects/<project-id>/project.json
- projects/<project-id>/snapshots/<snapshot-id>.json
- projects/<project-id>/variants/<variant-id>.json
- library/index.json, library/<slug>.metal, library/<slug>.json (metadata)
- presets/<shader-id>/*.json (named parameter sets)

Schemas (illustrative):
- project.json
  {
    "id": "proj_2025_09_07",
    "name": "Ocean_Study",
    "created_at": "2025-09-07T17:00:00Z",
    "snapshots": ["snap_001", "snap_002"],
    "variants": ["var_main", "var_bold"],
    "notes": "Goals and constraints"
  }
- snapshot.json
  {
    "id": "snap_001",
    "time": 1.25,
    "seed": 42,
    "resolution": {"w":1920, "h":1080},
    "uniforms": {"turbulence": 0.5},
    "code_path": "shader.metal",
    "image_path": "../../screenshots/2025-09-07_..._ocean_snap1.png",
    "message": "Improved highlight rolloff"
  }
- variant.json
  {
    "id": "var_bold",
    "base_snapshot": "snap_001",
    "branch_reason": "Increase contrast, more aggressive motion",
    "history": ["snap_001", "snap_003", "snap_005"]
  }
- library/<slug>.json
  {
    "name": "Plasma",
    "tags": ["generative", "animated"],
    "description": "Classic sine-sum plasma with radial modulation",
    "difficulty": "beginner",
    "notes": "Explain trigonometric layering, center shifting",
    "presets": [
      {"name":"Calm","uniforms":{"speed":0.3}},
      {"name":"Storm","uniforms":{"speed":1.2}}
    ]
  }

## 5) Educational Shader Library
Categories & Examples:
- Generative: plasma, gradient, noise, ripples, flow fields
- Image FX: blur, sharpen, color remap, edge detect
- Animation: waves, spiral morphs, particle sheets
- 3D/Raymarch: SDFs (sphere/torus), lighting demos
Each entry: code, annotated explanation, presets, references, performance notes.

## 6) Overlays & Debugging
- UV grid, centerlines, gamut warn, safe area
- Pixel sampler (shows RGBA, UV, depth if available)
- Buffer capture (final, depth, normal, uv, motion) when supported

## 7) Performance HUD
- FPS, gpu_ms (avg/p95), cpu_ms, draw calls
- Memory report: textures bytes, buffers bytes, peak transient bytes

## 8) Keyboard Shortcuts (examples)
- Cmd+Enter: Compile
- Space: Play/Pause
- Cmd+S: Save Snapshot
- Cmd+B: Set Baseline
- Cmd+D: Diff Against Baseline

## 9) Milestones / Build Order
M1 (REPL MVP): Compile, Canvas render, Time/Seed/Resolution controls, Uniform sliders, Screenshot
M2 (Debug): Error panel, Overlays, Pixel sampler, Baseline/Diff
M3 (Exploration): Sweep/Compare, Projects/Snapshots/Variants
M4 (Education): Library grid, details, presets, ‚ÄúOpen in REPL‚Äù
M5 (Polish): MCP Explorer UI, History log, Accessibility, Device profiles

## 10) MCP Integration in UI
- Tool Explorer lists tools from MCP, shows input schema and examples
- One-click run with last args; response view (text/image)
- Log of recent tool invocations with parameters and outcomes

This design centers on making shader iteration observable, controllable, and educational‚Äîso Claude can truly learn by seeing. 

```

- **/Users/erichowens/coding/metal-shader-mcp/CLAUDE.md**
```
# Claude Shader REPL Guide

A pragmatic guide for building beautiful shaders with fast, visual iteration. This replaces the previous aspirational document and aligns with our WARP.md single-agent workflow.

## Why a REPL?
Claude can only learn to write good shaders if it can immediately see the results of each change. The REPL provides eyes (render), hands (uniforms/time), a notebook (snapshots/baselines), and a lab bench (sweep, profile, compare).

## Prioritized MCP Tooling (source of truth)
MVP (build in this order):
1) set_shader, compile_shader, get_compilation_errors
2) run_frame/screenshot, set_uniforms, set_time/play/pause/set_playback_speed
3) set_resolution/aspect/seed/mouse
4) profile_frame, set_baseline/diff_against_baseline
5) sweep_param/grid + compare_variants
6) sample_pixel/capture_histogram/toggle_overlays
7) library, assets, snapshots
8) explain_error/auto_tune (optional)

See DESIGN.md and WARP.md for details.

## REPL Workflows (recipes Claude should follow)

### 1. Basic Loop
- set_shader(code)
- compile_shader() ‚Üí if errors: get_compilation_errors() and fix
- run_frame(time, uniforms, resolution, seed)
- screenshot("desc") and record observations

### 2. Debugging Compilation Errors
- get_compilation_errors() ‚Üí use line/col/snippet to patch code
- recompile quickly (keep changes minimal)

### 3. Explore Parameters
- set_uniforms({ name: value }) and rerender
- sweep_param(name, from, to, steps) ‚Üí produce contact sheet
- compare_variants([...]) for A/B

### 4. Guard Against Regressions
- set_baseline("name") ‚Üí later diff_against_baseline("name", threshold)

### 5. Make it Reproducible
- set_seed(42), set_time(1.25), set_resolution("1080p")
- save_snapshot() prior to risky edits; branch_snapshot() for explorations

### 6. Education & Inspiration
- get_example_shader(type) ‚Üí study ‚Üí modify ‚Üí document

## Conventions and Storage
- Communication files under Resources/communication/*.json
- Screenshots: Resources/screenshots/YYYY-MM-DD_HH-MM-SS_<desc>.png
- Projects, snapshots, variants, presets: Resources/projects/<project-id>/*.json
- Educational shader library: Resources/library/*.metal + metadata.json

## WARP Alignment (must-do after each significant change)
1. Update BUGS.md if issues discovered
2. Update CHANGELOG.md with what changed
3. Capture visual evidence (screenshots)
4. Commit to git with descriptive message
5. Run tests or add new ones for new functionality

## Success Metrics
- REPL round‚Äëtrip under 1s for typical edits
- Deterministic renders given (time, seed, resolution)
- Visual regressions caught by baseline/diff
- Library examples compile and render on first try
- Claude can iteratively improve a shader across snapshots

---

This document is deliberately practical. Build the REPL, use it constantly, and document the journey with visuals and tests.

```

- **/Users/erichowens/coding/metal-shader-mcp/src/simple-mcp.ts**
```
#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { execSync } from 'child_process';
import { writeFileSync, readFileSync, existsSync } from 'fs';
import { join } from 'path';

const server = new Server(
  {
    name: 'shader-playground-mcp',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Paths
const SCREENSHOTS_DIR = join(process.cwd(), 'Resources/screenshots');

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'set_shader',
        description: 'Set the shader code in the ShaderPlayground app',
        inputSchema: {
          type: 'object',
          properties: {
            shader_code: {
              type: 'string',
              description: 'Complete Metal fragment shader code',
            },
            description: {
              type: 'string',
              description: 'Description of what this shader does',
            },
          },
          required: ['shader_code'],
        },
      },
      {
        name: 'get_compilation_errors',
        description: 'Get detailed compilation errors and warnings from the current shader',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_current_shader',
        description: 'Get the current shader code from ShaderPlayground app',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'export_frame',
        description: 'Export a single rendered frame at a specific time',
        inputSchema: {
          type: 'object',
          properties: {
            description: {
              type: 'string',
              description: 'Description for the frame export',
            },
            time: {
              type: 'number',
              description: 'Time in seconds (optional, uses current time if not specified)',
            },
          },
          required: ['description'],
        },
      },
      {
        name: 'export_sequence',
        description: 'Export a sequence of frames over time to see shader animation',
        inputSchema: {
          type: 'object',
          properties: {
            description: {
              type: 'string',
              description: 'Description for the sequence',
            },
            duration: {
              type: 'number',
              description: 'Duration in seconds (default: 5.0)',
            },
            fps: {
              type: 'number',
              description: 'Frames per second (default: 30)',
            },
          },
          required: ['description'],
        },
      },
      {
        name: 'set_uniforms',
        description: 'Set uniform values for the current shader',
        inputSchema: {
          type: 'object',
          properties: {
            uniforms: {
              type: 'object',
              description: 'Key-value pairs of uniform names and values',
              additionalProperties: {
                oneOf: [
                  { type: 'number' },
                  { type: 'array', items: { type: 'number' } }
                ]
              }
            },
          },
          required: ['uniforms'],
        },
      },
      {
        name: 'list_uniforms',
        description: 'List all available uniforms and their current values',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_example_shader',
        description: 'Get an example Metal shader to experiment with',
        inputSchema: {
          type: 'object',
          properties: {
            type: {
              type: 'string',
              enum: ['basic', 'plasma', 'gradient', 'noise', 'spiral', 'ripples'],
              description: 'Type of example shader',
            },
          },
          required: ['type'],
        },
      },

      // ---- Next set of REPL tools (schemas only; handlers stubbed below) ----
      {
        name: 'run_frame',
        description: 'Render a single frame deterministically and return image',
        inputSchema: {
          type: 'object',
          properties: {
            time: { type: 'number', description: 'Time in seconds' },
            uniforms: { type: 'object', description: 'Key-value uniforms' },
            resolution: {
              type: 'object',
              properties: { w: { type: 'number' }, h: { type: 'number' } },
              required: ['w','h']
            },
            seed: { type: 'number', description: 'Random seed' },
            colorspace: { type: 'string', enum: ['sRGB','P3'] }
          },
          required: ['time','resolution']
        }
      },
      { name: 'set_time', description: 'Set the current timeline time', inputSchema: { type: 'object', properties: { time: { type: 'number' } }, required: ['time'] } },
      { name: 'play', description: 'Start timeline playback', inputSchema: { type: 'object', properties: {} } },
      { name: 'pause', description: 'Pause timeline playback', inputSchema: { type: 'object', properties: {} } },
      { name: 'set_playback_speed', description: 'Set timeline speed multiplier', inputSchema: { type: 'object', properties: { speed: { type: 'number' } }, required: ['speed'] } },

      { name: 'set_resolution', description: 'Set render resolution via preset or explicit', inputSchema: { type: 'object', properties: { preset: { type:'string', enum: ['720p','1080p','4k','square','vertical'] }, w: { type:'number' }, h: { type:'number' } } } },
      { name: 'set_aspect', description: 'Set aspect ratio', inputSchema: { type: 'object', properties: { aspect: { type: 'string', enum: ['16:9','9:16','1:1','4:3','3:4','3:2','2:3'] } }, required: ['aspect'] } },
      { name: 'set_device_profile', description: 'Apply device-specific defaults', inputSchema: { type: 'object', properties: { device: { type: 'string', enum: ['macOS','iPhone','iPad'] } }, required: ['device'] } },

      { name: 'set_seed', description: 'Set deterministic random seed', inputSchema: { type: 'object', properties: { seed: { type: 'number' } }, required: ['seed'] } },
      { name: 'randomize_seed', description: 'Randomize seed', inputSchema: { type: 'object', properties: {} } },

      { name: 'set_mouse', description: 'Set mouse position (normalized or px depending on app)', inputSchema: { type: 'object', properties: { x: { type:'number' }, y: { type:'number' } }, required: ['x','y'] } },
      { name: 'simulate_touch_path', description: 'Drive interaction along a path', inputSchema: { type: 'object', properties: { path: { type:'array', items: { type:'array', items:{ type:'number' } } } }, required: ['path'] } },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'set_shader': {
        if (!args) {
            return { text: [{ text: 'Missing arguments for set_shader' }] };
        }
        
        const shaderCode = args.shader_code as string;
        const description = args.description as string || 'mcp_shader';
        
        // Write command to communication file
        const command = {
          action: 'set_shader',
          shader_code: shaderCode,
          description,
          timestamp: Date.now()
        };
        
        const commandFile = 'Resources/communication/commands.json';
        const statusFile = 'Resources/communication/status.json';
        
        try {
          // Ensure communication directory exists
          execSync('mkdir -p Resources/communication');
          
          // Write command
          writeFileSync(commandFile, JSON.stringify(command, null, 2));
          
          // Wait for command to be processed
          let attempts = 0;
          const maxAttempts = 50; // 5 seconds
          
          while (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            
            if (!existsSync(commandFile)) {
              // Command was processed
              if (existsSync(statusFile)) {
                const status = JSON.parse(readFileSync(statusFile, 'utf8'));
                if (status.success) {
                  return {
                    content: [
                      {
                        type: 'text',
                        text: `‚úÖ Shader code updated successfully!\n\n${description}\n\nThe shader has been compiled and is now running in the ShaderPlayground app.`,
                      },
                    ],
                  };
                } else {
                  return {
                    content: [
                      {
                        type: 'text',
                        text: `‚ùå Shader update failed: ${status.error || 'Unknown error'}`,
                      },
                    ],
                    isError: true,
                  };
                }
              }
              break;
            }
            attempts++;
          }
          
          if (attempts >= maxAttempts) {
            return {
              content: [
                {
                  type: 'text',
                  text: '‚è∞ Shader update timed out. Make sure ShaderPlayground app is running.',
                },
              ],
              isError: true,
            };
          }
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `‚ùå Failed to set shader: ${error}`,
              },
            ],
            isError: true,
          };
        }
      }
      
      case 'get_current_shader': {
        try {
          const shaderFile = 'Resources/communication/current_shader.metal';
          if (existsSync(shaderFile)) {
            const currentShader = readFileSync(shaderFile, 'utf8');
            return {
              content: [
                {
                  type: 'text',
                  text: `üìù Current shader code:\n\n\`\`\`metal\n${currentShader}\n\`\`\``,
                },
              ],
            };
          } else {
            return {
              content: [
                {
                  type: 'text',
                  text: '‚ùå No shader state file found. Make sure ShaderPlayground app is running.',
                },
              ],
              isError: true,
            };
          }
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `‚ùå Failed to get shader: ${error}`,
              },
            ],
            isError: true,
          };
        }
      }
      
      case 'export_frame': {
        if (!args) {
            return { text: [{ text: 'Missing arguments for export_frame' }] };
        }
        
        const description = args.description as string;
        const time = args.time as number | undefined;
        
        // Trigger frame export via AppleScript to call app function
        const timeParam = time !== undefined ? `, time: ${time}` : '';
        const appleScriptCmd = `osascript -e 'tell application "ShaderPlayground" to activate' -e 'delay 0.5' -e 'tell application "System Events" to tell process "ShaderPlayground" to click button "Export Frame" of window 1'`;
        
        try {
          execSync(appleScriptCmd, { encoding: 'utf8' });
          
          // Wait a moment for export to complete
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Find the latest export
          const exportsDir = 'Resources/exports';
          const latestFile = execSync(`ls -t ${exportsDir}/*.png | head -1`, { encoding: 'utf8' }).trim();
          
          if (existsSync(latestFile)) {
            const imageBuffer = readFileSync(latestFile);
            
            return {
              content: [
                {
                  type: 'image',
                  data: imageBuffer.toString('base64'),
                  mimeType: 'image/png',
                },
                {
                  type: 'text',
                  text: `üé® Frame exported: ${description}\n\nFile: ${latestFile}\n\nThis is a direct render from the Metal shader at ${time !== undefined ? `t=${time}s` : 'current time'}.`,
                },
              ],
            };
          } else {
            throw new Error('Export file not found');
          }
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `‚ùå Export failed: ${error}\n\nMake sure ShaderPlayground app is running and visible.`,
              },
            ],
            isError: true,
          };
        }
      }

      case 'get_compilation_errors': {
        try {
          const errorsFile = 'Resources/communication/compilation_errors.json';
          if (existsSync(errorsFile)) {
            const errorsData = JSON.parse(readFileSync(errorsFile, 'utf8'));
            
            let response = 'üîç **Compilation Status:**\n\n';
            
            if (errorsData.errors && errorsData.errors.length > 0) {
              response += '‚ùå **Errors:**\n';
              errorsData.errors.forEach((error: any, i: number) => {
                response += `${i+1}. Line ${error.line}: ${error.message}\n`;
                if (error.suggestion) {
                  response += `   üí° Suggestion: ${error.suggestion}\n`;
                }
              });
              response += '\n';
            }
            
            if (errorsData.warnings && errorsData.warnings.length > 0) {
              response += '‚ö†Ô∏è **Warnings:**\n';
              errorsData.warnings.forEach((warning: any, i: number) => {
                response += `${i+1}. Line ${warning.line}: ${warning.message}\n`;
              });
              response += '\n';
            }
            
            if ((!errorsData.errors || errorsData.errors.length === 0) && 
                (!errorsData.warnings || errorsData.warnings.length === 0)) {
              response += '‚úÖ **No compilation errors or warnings!**\n\n';
              response += 'Shader compiled successfully and is ready to render.';
            }
            
            return {
              content: [{
                type: 'text',
                text: response
              }]
            };
          } else {
            return {
              content: [{
                type: 'text',
                text: 'üìù No compilation status available. Make sure ShaderPlayground app is running and has compiled a shader.'
              }]
            };
          }
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `‚ùå Failed to get compilation errors: ${error}`
            }],
            isError: true
          };
        }
      }
      
      case 'set_uniforms': {
        if (!args) {
          return { content: [{ type: 'text', text: 'Missing arguments for set_uniforms' }], isError: true };
        }
        
        const uniforms = args.uniforms as Record<string, number | number[]>;
        
        // Write uniforms to communication file for ShaderPlayground to pick up
        const uniformsFile = 'Resources/communication/uniforms.json';
        try {
          execSync('mkdir -p Resources/communication');
          writeFileSync(uniformsFile, JSON.stringify({ uniforms, timestamp: Date.now() }, null, 2));
          
          let response = '‚úÖ **Uniforms Updated:**\n\n';
          for (const [name, value] of Object.entries(uniforms)) {
            if (Array.isArray(value)) {
              response += `üî¢ ${name}: [${value.join(', ')}]\n`;
            } else {
              response += `üî¢ ${name}: ${value}\n`;
            }
          }
          
          return {
            content: [{
              type: 'text',
              text: response
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `‚ùå Failed to set uniforms: ${error}`
            }],
            isError: true
          };
        }
      }
      
      case 'list_uniforms': {
        try {
          const uniformsFile = 'Resources/communication/uniforms.json';
          if (existsSync(uniformsFile)) {
            const uniformsData = JSON.parse(readFileSync(uniformsFile, 'utf8'));
            
            let response = 'üìä **Current Uniforms:**\n\n';
            if (uniformsData.uniforms && Object.keys(uniformsData.uniforms).length > 0) {
              for (const [name, value] of Object.entries(uniformsData.uniforms)) {
                if (Array.isArray(value)) {
                  response += `üî¢ ${name}: [${(value as number[]).join(', ')}]\n`;
                } else {
                  response += `üî¢ ${name}: ${value}\n`;
                }
              }
            } else {
              response += 'üìù No uniforms currently set.';
            }
            
            return {
              content: [{
                type: 'text',
                text: response
              }]
            };
          } else {
            return {
              content: [{
                type: 'text',
                text: 'üìù No uniforms file found. No uniforms have been set yet.'
              }]
            };
          }
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `‚ùå Failed to list uniforms: ${error}`
            }],
            isError: true
          };
        }
      }
      
      case 'get_example_shader': {
        if (!args) {
            return { text: [{ text: 'Missing arguments for list_example_shaders' }] };
        }
        
        const type = args.type as string;
        
        const examples = {
          basic: `#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    
    // Simple animated gradient
    float3 color = 0.5 + 0.5 * cos(time + uv.xyx + float3(0, 2, 4));
    
    return float4(color, 1.0);
}`,
          
          plasma: `#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    uv = uv * 2.0 - 1.0;
    
    float v = 0.0;
    v += sin((uv.x + time));
    v += sin((uv.y + time) / 2.0);
    v += sin((uv.x + uv.y + time) / 2.0);
    
    float cx = uv.x + 0.5 * sin(time / 5.0);
    float cy = uv.y + 0.5 * cos(time / 3.0);
    v += sin(sqrt(100.0 * (cx * cx + cy * cy) + 1.0) + time);
    
    v = v / 2.0;
    
    float3 col = float3(1, sin(3.14159 * v), cos(3.14159 * v));
    
    return float4(col, 1.0);
}`,

          gradient: `#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    
    float3 col = mix(float3(1.0, 0.5, 0.5), float3(0.5, 0.5, 1.0), uv.y);
    col = mix(col, float3(1.0, 1.0, 0.5), sin(time) * 0.5 + 0.5);
    
    return float4(col, 1.0);
}`,

          noise: `#include <metal_stdlib>
using namespace metal;

float random(float2 st) {
    return fract(sin(dot(st.xy, float2(12.9898,78.233))) * 43758.5453123);
}

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    
    float noise = random(uv + time);
    float3 col = float3(noise);
    
    return float4(col, 1.0);
}`,

          spiral: `#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    uv = uv * 2.0 - 1.0;
    
    float angle = atan2(uv.y, uv.x);
    float radius = length(uv);
    
    float spiral = sin(radius * 10.0 - angle * 3.0 + time * 2.0);
    float3 col = float3(spiral * 0.5 + 0.5);
    col *= smoothstep(0.8, 0.0, radius);
    
    return float4(col, 1.0);
}`,

          ripples: `#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    uv = uv * 2.0 - 1.0;
    
    float dist = length(uv);
    float ripple = sin(dist * 20.0 - time * 8.0) * exp(-dist * 3.0);
    
    float3 col = float3(0.5 + ripple * 0.5);
    col *= smoothstep(1.0, 0.0, dist);
    
    return float4(col, 1.0);
}`
        };
        
        const shaderCode = examples[type as keyof typeof examples];
        if (!shaderCode) {
          throw new Error(`Unknown shader type: ${type}`);
        }
        
        return {
          content: [
            {
              type: 'text',
              text: `Here's a ${type} shader example:\n\n\`\`\`metal\n${shaderCode}\n\`\`\`\n\nTo see this shader in action:\n1. Copy this code\n2. Paste it into the ShaderPlayground app\n3. Use the take_screenshot tool to capture the result`,
            },
          ],
        };
      }

      // ---- Stub handlers for newly-added tools ----
      case 'run_frame':
      case 'set_time':
      case 'play':
      case 'pause':
      case 'set_playback_speed':
      case 'set_resolution':
      case 'set_aspect':
      case 'set_device_profile':
      case 'set_seed':
      case 'randomize_seed':
      case 'set_mouse':
      case 'simulate_touch_path': {
        return {
          content: [{
            type: 'text',
            text: `üß™ Tool '${name}' acknowledged (schema ready). Implementation pending.`
          }]
        };
      }

      case 'save_snapshot': {
        // Bridge to app via command file
        try {
          const description = (args && (args as any).description) || 'snapshot';
          const fs = await import('fs');
          await fs.promises.mkdir('Resources/communication', { recursive: true });
          await fs.promises.writeFile('Resources/communication/commands.json', JSON.stringify({ action: 'save_snapshot', description, timestamp: Date.now() }, null, 2));
          return { content: [{ type: 'text', text: 'üñºÔ∏è Snapshot requested. App will capture code+image+meta.' }] };
        } catch (e: any) {
          return { content: [{ type: 'text', text: `‚ùå Failed to request snapshot: ${e.message}` }], isError: true };
        }
      }

      // Session & snapshots
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
      isError: true,
    };
  }
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('Shader Playground MCP server running on stdio');
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

```

- **/Users/erichowens/coding/metal-shader-mcp/ShaderPlayground.swift**
```
import SwiftUI
import MetalKit
import Metal
import UniformTypeIdentifiers
import CryptoKit
import AppKit

@main
struct ShaderPlaygroundApp: App {
    @StateObject var appState = AppState()

    var body: some Scene {
        WindowGroup("Claude's Shader Playground") {
            AppShellView(initialTab: Self.initialTabFromArgs())
                .environmentObject(appState)
                .frame(minWidth: 1000, minHeight: 700)
        }
    }

    private static func initialTabFromArgs() -> AppTab {
        let args = CommandLine.arguments
        func map(_ s: String) -> AppTab? {
            switch s.lowercased() {
            case "repl": return .repl
            case "library": return .library
            case "projects": return .projects
            case "tools", "mcp", "mcp-tools": return .tools
            case "history", "sessions": return .history
            default: return nil
            }
        }
        if let i = args.firstIndex(of: "--tab"), i+1 < args.count, let t = map(args[i+1]) { return t }
        if let i = args.firstIndex(of: "-t"), i+1 < args.count, let t = map(args[i+1]) { return t }
        return .repl
    }
}

struct ContentView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var renderer = MetalShaderRenderer()
    @StateObject private var session = SessionRecorder()
@State private var shaderCode = defaultShader
    @State private var shaderMeta = ShaderMetadata.from(code: defaultShader, path: nil)
    
    let communicationDir = "Resources/communication"
    let shaderStateFile = "Resources/communication/current_shader.metal"
    let commandFile = "Resources/communication/commands.json"
    let statusFile = "Resources/communication/status.json"
    let errorsFile = "Resources/communication/compilation_errors.json"
    
    var body: some View {
        HStack(spacing: 0) {
            // Left: Code Editor
            VStack {
                Text("Shader Code")
                    .font(.headline)
                    .padding()
                
TextEditor(text: $shaderCode)
                    .font(.system(.body, design: .monospaced))
                    .onChange(of: shaderCode) { newCode in
                        renderer.updateShader(newCode)
                        shaderMeta = ShaderMetadata.from(code: newCode, path: shaderStateFile)
                        writeCurrentShaderMeta()
                    }
                
HStack(spacing: 12) {
                    Button("Compile & Update") {
renderer.updateShader(shaderCode)
                        shaderMeta = ShaderMetadata.from(code: shaderCode, path: shaderStateFile)
                        writeCurrentShaderMeta()
                    }
                    Button("Save As‚Ä¶") {
                        saveAsShaderDialog()
                    }
                }
                .padding(.horizontal)
                .padding(.bottom)
            }
            .frame(maxWidth: .infinity)
            
            Divider()
            
            // Right: Metal Preview
VStack {
                Text("Live Preview")
                    .font(.headline)
                    .padding(.top)
                // Shader name and description (from docstring)
                VStack(alignment: .leading, spacing: 4) {
                    Text(shaderMeta.name.isEmpty ? "Untitled Shader" : shaderMeta.name)
                        .font(.title3).bold()
                        .frame(maxWidth: .infinity, alignment: .leading)
                    if !shaderMeta.description.isEmpty {
                        Text(shaderMeta.description)
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }
                }
                .padding(.horizontal)
                .padding(.bottom, 4)
                
                MetalView(renderer: renderer)
                    .aspectRatio(1.0, contentMode: .fit)
                    .padding()
                
                HStack {
                    Button("Export Frame") {
                        renderer.saveScreenshot()
                    }
                    
                    Button("Export Sequence") {
                        renderer.exportFrameSequence(description: "animation_sequence")
                    }
                    
                    Text("FPS: \(Int(renderer.fps))")
                        .font(.system(.body, design: .monospaced))
                }
                .padding()
            }
            .frame(maxWidth: .infinity)
        }
        .onAppear {
            setupCommunication()
            startMonitoringCommands()
        }
    }
    
    // MARK: - Communication Functions
private func setupCommunication() {
        // Ensure metadata is initialized
        shaderMeta = ShaderMetadata.from(code: shaderCode, path: shaderStateFile)
        writeCurrentShaderMeta()
        // Create communication directory
        try? FileManager.default.createDirectory(atPath: communicationDir, withIntermediateDirectories: true)
        
        // Initialize shader state file
        try? shaderCode.write(toFile: shaderStateFile, atomically: true, encoding: .utf8)
        
        // Initialize status file
        let status = ["status": "ready", "timestamp": Date().timeIntervalSince1970] as [String: Any]
        if let statusData = try? JSONSerialization.data(withJSONObject: status) {
            try? statusData.write(to: URL(fileURLWithPath: statusFile))
        }
    }
    
private func startMonitoringCommands() {
        // Ensure communication dir exists
        try? FileManager.default.createDirectory(atPath: communicationDir, withIntermediateDirectories: true)
        Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            checkForCommands()
        }
    }
    
    private func checkForCommands() {
        guard FileManager.default.fileExists(atPath: commandFile) else { return }
        
        do {
            let commandData = try Data(contentsOf: URL(fileURLWithPath: commandFile))
            let command = try JSONSerialization.jsonObject(with: commandData) as? [String: Any]
            
            if let action = command?["action"] as? String {
                switch action {
case "set_shader":
                    if let newCode = command?["shader_code"] as? String {
                        let desc = command?["description"] as? String
                        let noSnapshot = (command?["no_snapshot"] as? Bool) ?? false
                        DispatchQueue.main.async {
                            self.shaderCode = newCode
                            self.renderer.updateShader(newCode)
                            if !noSnapshot {
                                self.session.recordSnapshot(code: newCode, renderer: self.renderer, label: desc)
                            }
                        }
                    }
case "get_shader_meta":
                    // Write current shader meta (already maintained)
                    self.writeCurrentShaderMeta()

                case "set_shader_with_meta":
                    let newCode = command?["shader_code"] as? String
                    let name = command?["name"] as? String
                    let desc = command?["description"] as? String
                    let path = command?["path"] as? String
                    let save = (command?["save"] as? Bool) ?? false
                    let noSnapshot = (command?["no_snapshot"] as? Bool) ?? false
                    DispatchQueue.main.async {
                        if let newCode = newCode {
                            self.shaderCode = newCode
                            self.renderer.updateShader(newCode)
                        }
                        // Update metadata
                        var meta = ShaderMetadata.from(code: self.shaderCode, path: self.shaderStateFile)
                        if let name = name { meta.name = name }
                        if let desc = desc { meta.description = desc }
                        if let path = path, !path.isEmpty { meta.path = path }
                        self.shaderMeta = meta
                        self.writeCurrentShaderMeta()
                        // Save to path if requested
                        if save, let p = meta.path, !p.isEmpty {
                            Self.writeTextSafely(self.shaderCode, toPath: p)
                        }
                        if !noSnapshot {
                            self.session.recordSnapshot(code: self.shaderCode, renderer: self.renderer, label: "set_shader_with_meta")
                        }
                    }

                case "list_library_entries":
                    self.writeLibraryIndex()

                case "save_snapshot":
                    let desc = command?["description"] as? String ?? "snapshot"
                    DispatchQueue.main.async {
                        self.session.recordSnapshot(code: self.shaderCode, renderer: self.renderer, label: desc)
                    }
                case "export_frame":
                    let description = command?["description"] as? String ?? "mcp_export"
                    let time = command?["time"] as? Float
                    renderer.exportFrame(description: description, time: time)
                    
                case "set_tab":
                    if let tabName = command?["tab"] as? String {
                        DispatchQueue.main.async {
                            let lower = tabName.lowercased()
                            if lower == "repl" { self.appState.selectedTab = .repl }
                            else if lower == "library" { self.appState.selectedTab = .library }
                            else if lower == "projects" { self.appState.selectedTab = .projects }
                            else if lower == "tools" || lower == "mcp" || lower == "mcp-tools" { self.appState.selectedTab = .tools }
                            else if lower == "history" || lower == "sessions" { self.appState.selectedTab = .history }
                        }
                    }
                case "export_sequence":
                    let description = command?["description"] as? String ?? "mcp_sequence"
                    let duration = command?["duration"] as? Float ?? 5.0
                    let fps = command?["fps"] as? Int ?? 30
                    renderer.exportFrameSequence(description: description, duration: duration, fps: fps)
                    
                default:
                    break
                }
                
                // Update status
                updateStatus(action: action, success: true)
                
                // Remove command file
                try? FileManager.default.removeItem(atPath: commandFile)
            }
        } catch {
            updateStatus(action: "unknown", success: false, error: error.localizedDescription)
            try? FileManager.default.removeItem(atPath: commandFile)
        }
    }
    
    private func updateStatus(action: String, success: Bool, error: String? = nil) {
        let status = [
            "last_action": action,
            "success": success,
            "timestamp": Date().timeIntervalSince1970,
            "error": error as Any
        ] as [String: Any]
        
        if let statusData = try? JSONSerialization.data(withJSONObject: status) {
            try? statusData.write(to: URL(fileURLWithPath: statusFile))
        }
        
        // Also update shader state file
        try? shaderCode.write(toFile: shaderStateFile, atomically: true, encoding: .utf8)
    }
}

// MARK: - Shader Metadata
struct ShaderMetadata: Codable {
    var name: String
    var description: String
    var path: String?

    static func from(code: String, path: String?) -> ShaderMetadata {
        // Extract the first block comment /** ... */ as docstring
        // Fallbacks if not present
        let trimmed = code.trimmingCharacters(in: .whitespacesAndNewlines)
        var title = ""
        var desc = ""
        if let startRange = trimmed.range(of: "/**"), let endRange = trimmed.range(of: "*/", range: startRange.upperBound..<trimmed.endIndex) {
            let doc = String(trimmed[startRange.upperBound..<endRange.lowerBound])
            // Split into lines, strip leading * and spaces
            let lines = doc.split(separator: "\n").map { line -> String in
                var s = String(line)
                if s.trimmingCharacters(in: .whitespaces).hasPrefix("*") {
                    s = s.replacingOccurrences(of: "*", with: "", options: [], range: s.range(of: "*"))
                }
                return s.trimmingCharacters(in: .whitespaces)
            }
            // First non-empty line as title, subsequent non-empty lines until blank as description (joined)
            var i = 0
            while i < lines.count && lines[i].isEmpty { i += 1 }
            if i < lines.count { title = lines[i]; i += 1 }
            var descLines: [String] = []
            while i < lines.count {
                let l = lines[i]
                if l.isEmpty { break }
                descLines.append(l)
                i += 1
            }
            desc = descLines.joined(separator: " ")
        }
        if title.isEmpty { title = "Untitled Shader" }
        return ShaderMetadata(name: title, description: desc, path: path)
    }
}

extension ContentView {
    func saveAsShaderDialog() {
        let panel = NSSavePanel()
        panel.allowedFileTypes = ["metal"]
        panel.canCreateDirectories = true
        panel.title = "Save Shader As"
        // Default directory: ./shaders
        let shadersDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath).appendingPathComponent("shaders")
        try? FileManager.default.createDirectory(at: shadersDir, withIntermediateDirectories: true)
        panel.directoryURL = shadersDir
        panel.nameFieldStringValue = (shaderMeta.name.isEmpty ? "Untitled Shader" : shaderMeta.name).replacingOccurrences(of: " ", with: "_").lowercased() + ".metal"
        if panel.runModal() == .OK, let url = panel.url {
            let path = url.path
            Self.writeTextSafely(shaderCode, toPath: path)
            // Update meta path and rewrite meta
            shaderMeta.path = path
            writeCurrentShaderMeta()
        }
    }

    static func writeTextSafely(_ text: String, toPath path: String) {
        let dir = (path as NSString).deletingLastPathComponent
        try? FileManager.default.createDirectory(atPath: dir, withIntermediateDirectories: true)
        // If file exists, replace
        if FileManager.default.fileExists(atPath: path) {
            _ = try? FileManager.default.removeItem(atPath: path)
        }
        try? text.write(toFile: path, atomically: true, encoding: .utf8)
    }

    func writeLibraryIndex() {
        let shadersDir = "shaders"
        var entries: [[String: Any]] = []
        if let files = try? FileManager.default.contentsOfDirectory(atPath: shadersDir) {
            for fn in files where fn.hasSuffix(".metal") {
                let full = shadersDir + "/" + fn
                if let code = try? String(contentsOfFile: full) {
                    let meta = ShaderMetadata.from(code: code, path: full)
                    entries.append([
                        "name": meta.name,
                        "description": meta.description,
                        "path": full
                    ])
                }
            }
        }
        let obj: [String: Any] = [
            "entries": entries,
            "count": entries.count,
            "timestamp": Date().timeIntervalSince1970
        ]
        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
            try? data.write(to: URL(fileURLWithPath: communicationDir + "/library_index.json"))
        }
    }
    func writeCurrentShaderMeta() {
        let meta = shaderMeta
        let obj: [String: Any] = [
            "name": meta.name,
            "description": meta.description,
            "path": meta.path ?? "",
            "timestamp": Date().timeIntervalSince1970
        ]
        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
            try? FileManager.default.createDirectory(atPath: communicationDir, withIntermediateDirectories: true)
            try? data.write(to: URL(fileURLWithPath: communicationDir + "/shader_meta.json"))
        }
    }
}

// MARK: - Metal Renderer
class MetalShaderRenderer: ObservableObject {
    private let device: MTLDevice
    private let commandQueue: MTLCommandQueue
    @Published var fps: Double = 0
    private var pipelineState: MTLRenderPipelineState?
    private var startTime = CACurrentMediaTime()
    
    // Uniform override support (from Resources/communication/uniforms.json)
    private let uniformsFile = "Resources/communication/uniforms.json"
    private var overrideTime: Float?
    private var overrideResolution: SIMD2<Float>?
    private var overrideMouse: SIMD2<Float>?
    
    init() {
        guard let device = MTLCreateSystemDefaultDevice(),
              let commandQueue = device.makeCommandQueue() else {
            fatalError("Metal is not supported")
        }
        
        self.device = device
        self.commandQueue = commandQueue
        
        // Compile default shader
        updateShader(defaultShader)
        
        // Start polling for uniform overrides
        Timer.scheduledTimer(withTimeInterval: 0.3, repeats: true) { [weak self] _ in
            self?.loadUniformOverrides()
        }
    }
    
    func updateShader(_ source: String) {
        do {
            let library = try device.makeLibrary(source: source, options: nil)
            guard let fragmentFunction = library.makeFunction(name: "fragmentShader") else {
                print("Could not find fragmentShader function")
                saveCompilationErrors(["Could not find fragmentShader function in shader code"], warnings: [])
                return
            }
            
            let pipelineDescriptor = MTLRenderPipelineDescriptor()
            pipelineDescriptor.vertexFunction = createVertexFunction()
            pipelineDescriptor.fragmentFunction = fragmentFunction
            pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm
            
            pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
            print("‚úÖ Shader compiled successfully")
            saveCompilationErrors([], warnings: []) // Clear errors on successful compile
            
        } catch {
            print("‚ùå Shader compilation failed: \(error)")
            let errorMessage = parseMetalError(error.localizedDescription)
            saveCompilationErrors([errorMessage], warnings: [])
        }
    }
    
    private func parseMetalError(_ errorString: String) -> String {
        // Parse Metal compiler errors to extract useful information
        if errorString.contains("program_source") {
            let lines = errorString.components(separatedBy: .newlines)
            for line in lines {
                if line.contains(":") && (line.contains("error:") || line.contains("warning:")) {
                    return line.trimmingCharacters(in: .whitespaces)
                }
            }
        }
        return errorString
    }
    
    private func saveCompilationErrors(_ errors: [String], warnings: [String]) {
        let errorsData = [
            "errors": errors.map { error in
                [
                    "message": error,
                    "line": extractLineNumber(from: error) ?? 0,
                    "suggestion": generateSuggestion(for: error)
                ]
            },
            "warnings": warnings.map { warning in
                [
                    "message": warning,
                    "line": extractLineNumber(from: warning) ?? 0
                ]
            },
            "timestamp": Date().timeIntervalSince1970
        ] as [String : Any]
        
        let errorsFile = "Resources/communication/compilation_errors.json"
        if let errorsJsonData = try? JSONSerialization.data(withJSONObject: errorsData, options: .prettyPrinted) {
            try? errorsJsonData.write(to: URL(fileURLWithPath: errorsFile))
        }
    }
    
    private func extractLineNumber(from error: String) -> Int? {
        // Extract line number from Metal error messages
        let pattern = ":(\\d+):"
        let regex = try? NSRegularExpression(pattern: pattern)
        let range = NSRange(location: 0, length: error.utf16.count)
        
        if let match = regex?.firstMatch(in: error, options: [], range: range) {
            let lineRange = Range(match.range(at: 1), in: error)
            if let lineRange = lineRange {
                return Int(String(error[lineRange]))
            }
        }
        return nil
    }
    
    private func generateSuggestion(for error: String) -> String {
        let errorLower = error.lowercased()
        
        if errorLower.contains("undeclared identifier") {
            return "Check variable and function names for typos. Make sure all variables are declared."
        } else if errorLower.contains("expected") {
            return "Check syntax - missing semicolons, brackets, or parentheses."
        } else if errorLower.contains("use of undeclared type") {
            return "Make sure all Metal types are spelled correctly (float, float2, float3, float4, etc.)."
        } else if errorLower.contains("fragmentshader") {
            return "Make sure your fragment function is named 'fragmentShader' and has the correct signature."
        }
        return "Review Metal shading language documentation for correct syntax."
    }
    
    // Load uniform overrides from file if present
    private func loadUniformOverrides() {
        guard FileManager.default.fileExists(atPath: uniformsFile) else { return }
        do {
            let data = try Data(contentsOf: URL(fileURLWithPath: uniformsFile))
            let obj = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            let uniforms = obj?["uniforms"] as? [String: Any]
            
            if let t = uniforms?["time"] as? NSNumber {
                overrideTime = t.floatValue
            } else if uniforms?.keys.contains("time") == true {
                // Explicitly allow clearing the override by setting null
                overrideTime = nil
            }
            
            if let res = uniforms?["resolution"] as? [NSNumber], res.count >= 2 {
                overrideResolution = SIMD2<Float>(res[0].floatValue, res[1].floatValue)
            } else if uniforms?.keys.contains("resolution") == true {
                overrideResolution = nil
            }
            
            if let m = uniforms?["mouse"] as? [NSNumber], m.count >= 2 {
                overrideMouse = SIMD2<Float>(m[0].floatValue, m[1].floatValue)
            } else if uniforms?.keys.contains("mouse") == true {
                overrideMouse = nil
            }
        } catch {
            // Ignore malformed uniforms file
        }
    }
    
    private func createVertexFunction() -> MTLFunction? {
        let vertexSource = """
        #include <metal_stdlib>
        using namespace metal;
        
        vertex float4 vertexShader(uint vertexID [[vertex_id]]) {
            float2 positions[4] = {
                float2(-1, -1),
                float2( 1, -1),
                float2(-1,  1),
                float2( 1,  1)
            };
            return float4(positions[vertexID], 0.0, 1.0);
        }
        """
        
        do {
            let library = try device.makeLibrary(source: vertexSource, options: nil)
            return library.makeFunction(name: "vertexShader")
        } catch {
            print("Failed to create vertex function: \(error)")
            return nil
        }
    }
    
    func render(in view: MTKView) {
        guard let drawable = view.currentDrawable,
              let pipelineState = pipelineState,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let renderPassDescriptor = view.currentRenderPassDescriptor else {
            return
        }
        
        let encoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!
        encoder.setRenderPipelineState(pipelineState)
        
        // Pass time, resolution, and optional mouse to shader (with overrides)
        var time = overrideTime ?? Float(CACurrentMediaTime() - startTime)
        var resolution = overrideResolution ?? SIMD2<Float>(Float(view.drawableSize.width), Float(view.drawableSize.height))
        var mouse = overrideMouse ?? SIMD2<Float>(0.0, 0.0)
        
        encoder.setFragmentBytes(&time, length: MemoryLayout<Float>.size, index: 0)
        encoder.setFragmentBytes(&resolution, length: MemoryLayout<SIMD2<Float>>.size, index: 1)
        encoder.setFragmentBytes(&mouse, length: MemoryLayout<SIMD2<Float>>.size, index: 2)
        
        encoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
        encoder.endEncoding()
        
        // Add completion handler BEFORE commit
        commandBuffer.addCompletedHandler { _ in
            DispatchQueue.main.async {
                self.fps = 60.0 // Simplified for now
            }
        }
        
        commandBuffer.present(drawable)
        commandBuffer.commit()
    }
    
    func saveScreenshot() {
        exportFrame(description: "manual_screenshot")
    }
    
    func exportFrame(description: String, time: Float? = nil) {
        guard let pipelineState = pipelineState,
              let commandBuffer = commandQueue.makeCommandBuffer() else {
            print("‚ùå Cannot export - no valid pipeline state")
            return
        }
        
        let width = 1024
        let height = 1024
        
        // Create export texture
        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(
            pixelFormat: .bgra8Unorm,
            width: width,
            height: height,
            mipmapped: false
        )
        textureDescriptor.usage = [.shaderWrite, .renderTarget]
        
        guard let exportTexture = device.makeTexture(descriptor: textureDescriptor) else {
            print("‚ùå Failed to create export texture")
            return
        }
        
        // Create render pass
        let renderPassDescriptor = MTLRenderPassDescriptor()
        renderPassDescriptor.colorAttachments[0].texture = exportTexture
        renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 1)
        renderPassDescriptor.colorAttachments[0].loadAction = .clear
        renderPassDescriptor.colorAttachments[0].storeAction = .store
        
        let encoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!
        encoder.setRenderPipelineState(pipelineState)
        
        // Set shader uniforms (respect overrides if provided)
        var exportTime = time ?? Float(CACurrentMediaTime() - startTime)
        if let t = overrideTime, time == nil { exportTime = t }
        var resolution = SIMD2<Float>(Float(width), Float(height))
        if let r = overrideResolution { resolution = r }
        var mouse = SIMD2<Float>(0.5, 0.5) // Default center for export
        if let m = overrideMouse { mouse = m }
        
        encoder.setFragmentBytes(&exportTime, length: MemoryLayout<Float>.size, index: 0)
        encoder.setFragmentBytes(&resolution, length: MemoryLayout<SIMD2<Float>>.size, index: 1)
        encoder.setFragmentBytes(&mouse, length: MemoryLayout<SIMD2<Float>>.size, index: 2)
        
        encoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
        encoder.endEncoding()
        
        // Save to file
        commandBuffer.addCompletedHandler { _ in
            self.saveTextureToFile(exportTexture, description: description, time: exportTime)
        }
        
        commandBuffer.commit()
    }
    
    func exportFrameSequence(description: String, duration: Float = 5.0, fps: Int = 30) {
        let frameCount = Int(duration * Float(fps))
        let timeStep = duration / Float(frameCount)
        
        print("üé¨ Exporting \(frameCount) frames over \(duration)s...")
        
        for frame in 0..<frameCount {
            let time = Float(frame) * timeStep
            let frameDesc = "\(description)_frame_\(String(format: "%04d", frame))_t\(String(format: "%.3f", time))"
            
            // Small delay to prevent overwhelming the GPU
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(frame) * 0.1) {
                self.exportFrame(description: frameDesc, time: time)
            }
        }
    }
    
    private func saveTextureToFile(_ texture: MTLTexture, description: String, time: Float) {
        let width = texture.width
        let height = texture.height
        let bytesPerRow = width * 4
        let imageByteCount = bytesPerRow * height
        
        let imageBytes = UnsafeMutableRawPointer.allocate(byteCount: imageByteCount, alignment: 1)
        defer { imageBytes.deallocate() }
        
        texture.getBytes(imageBytes, bytesPerRow: bytesPerRow, from: MTLRegionMake2D(0, 0, width, height), mipmapLevel: 0)
        
        // Create CGImage
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedFirst.rawValue)
        
        guard let dataProvider = CGDataProvider(dataInfo: nil, data: imageBytes, size: imageByteCount, releaseData: { _, _, _ in }),
              let cgImage = CGImage(width: width, height: height, bitsPerComponent: 8, bitsPerPixel: 32,
                                  bytesPerRow: bytesPerRow, space: colorSpace, bitmapInfo: bitmapInfo,
                                  provider: dataProvider, decode: nil, shouldInterpolate: false,
                                  intent: .defaultIntent) else {
            print("‚ùå Failed to create CGImage")
            return
        }
        
        // Save to file
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = dateFormatter.string(from: Date())
        let filename = "\(timestamp)_\(description).png"
        let resourcesDir = "Resources/exports"
        
        // Create directory if it doesn't exist
        try? FileManager.default.createDirectory(atPath: resourcesDir, withIntermediateDirectories: true)
        
        let url = URL(fileURLWithPath: "\(resourcesDir)/\(filename)")
        
        guard let destination = CGImageDestinationCreateWithURL(url as CFURL, "public.png" as CFString, 1, nil) else {
            print("‚ùå Failed to create image destination")
            return
        }
        
        // Add metadata
        let metadata: [String: Any] = [
            "time": time,
            "description": description,
            "resolution": "\(width)x\(height)",
            "export_timestamp": timestamp
        ]
        
        CGImageDestinationAddImage(destination, cgImage, metadata as CFDictionary)
        
        if CGImageDestinationFinalize(destination) {
            print("‚úÖ Frame exported: \(filename) (t=\(String(format: "%.3f", time)))")
        } else {
            print("‚ùå Failed to save frame: \(filename)")
        }
    }
}

// MARK: - Metal View
struct MetalView: NSViewRepresentable {
    let renderer: MetalShaderRenderer
    
    func makeNSView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = MTLCreateSystemDefaultDevice()
        mtkView.delegate = context.coordinator
        mtkView.preferredFramesPerSecond = 60
        mtkView.enableSetNeedsDisplay = false
        mtkView.isPaused = false
        mtkView.colorPixelFormat = .bgra8Unorm
        return mtkView
    }
    
    func updateNSView(_ nsView: MTKView, context: Context) {
        // Updates handled in delegate
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(renderer)
    }
    
    class Coordinator: NSObject, MTKViewDelegate {
        let renderer: MetalShaderRenderer
        
        init(_ renderer: MetalShaderRenderer) {
            self.renderer = renderer
        }
        
        func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
            // Handle resize if needed
        }
        
        func draw(in view: MTKView) {
            renderer.render(in: view)
        }
    }
}

// MARK: - Default Shader
let defaultShader = """
#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    
    // Simple animated gradient
    float3 color = 0.5 + 0.5 * cos(time + uv.xyx + float3(0, 2, 4));
    
    return float4(color, 1.0);
}
"""

```

- **/Users/erichowens/coding/metal-shader-mcp/src/index.ts**
```
#!/usr/bin/env node

/**
 * Metal Shader MCP Server
 * Live Metal shader development with real-time preview and hot reload
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from '@modelcontextprotocol/sdk/types.js';
import { compileShader, validateShader } from './compiler.js';
import { PreviewEngine } from './preview.js';
import { HotReloadManager } from './hotReload.js';
import { PerformanceProfiler } from './profiler.js';
import { ShaderParameters } from './parameters.js';

class MetalShaderMCPServer {
  private server: Server;
  private preview: PreviewEngine;
  private hotReload: HotReloadManager;
  private profiler: PerformanceProfiler;
  private parameters: ShaderParameters;

  constructor() {
    this.server = new Server(
      {
        name: 'metal-shader-mcp',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.preview = new PreviewEngine();
    this.hotReload = new HotReloadManager();
    this.profiler = new PerformanceProfiler();
    this.parameters = new ShaderParameters();

    this.setupHandlers();
  }

  private setupHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: this.getTools(),
    }));

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'compile_shader':
          return await this.handleCompileShader(args);
        
        case 'preview_shader':
          return await this.handlePreviewShader(args);
        
        case 'update_uniforms':
          return await this.handleUpdateUniforms(args);
        
        case 'profile_performance':
          return await this.handleProfilePerformance(args);
        
        case 'hot_reload':
          return await this.handleHotReload(args);
        
        case 'validate_shader':
          return await this.handleValidateShader(args);

        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  private getTools(): Tool[] {
    return [
      {
        name: 'compile_shader',
        description: 'Compile Metal shader code and return compilation results',
        inputSchema: {
          type: 'object',
          properties: {
            code: { type: 'string', description: 'Metal shader source code' },
            target: { 
              type: 'string', 
              enum: ['air', 'metallib', 'spirv'],
              description: 'Compilation target format' 
            },
            optimize: { type: 'boolean', description: 'Enable optimizations' },
          },
          required: ['code'],
        },
      },
      {
        name: 'preview_shader',
        description: 'Generate a preview image using the compiled shader',
        inputSchema: {
          type: 'object',
          properties: {
            shaderPath: { type: 'string', description: 'Path to compiled shader' },
            width: { type: 'number', description: 'Preview width in pixels' },
            height: { type: 'number', description: 'Preview height in pixels' },
            time: { type: 'number', description: 'Animation time (0-1)' },
            touchPoint: {
              type: 'object',
              properties: {
                x: { type: 'number' },
                y: { type: 'number' },
              },
            },
          },
          required: ['shaderPath'],
        },
      },
      {
        name: 'update_uniforms',
        description: 'Update shader uniform parameters',
        inputSchema: {
          type: 'object',
          properties: {
            uniforms: {
              type: 'object',
              description: 'Key-value pairs of uniform names and values',
            },
          },
          required: ['uniforms'],
        },
      },
      {
        name: 'profile_performance',
        description: 'Profile shader performance metrics',
        inputSchema: {
          type: 'object',
          properties: {
            shaderPath: { type: 'string', description: 'Path to compiled shader' },
            iterations: { type: 'number', description: 'Number of test iterations' },
            resolution: {
              type: 'object',
              properties: {
                width: { type: 'number' },
                height: { type: 'number' },
              },
            },
          },
          required: ['shaderPath'],
        },
      },
      {
        name: 'hot_reload',
        description: 'Enable hot reload for a shader file',
        inputSchema: {
          type: 'object',
          properties: {
            filePath: { type: 'string', description: 'Path to .metal file to watch' },
            enable: { type: 'boolean', description: 'Enable or disable hot reload' },
          },
          required: ['filePath', 'enable'],
        },
      },
      {
        name: 'validate_shader',
        description: 'Validate shader syntax and semantics',
        inputSchema: {
          type: 'object',
          properties: {
            code: { type: 'string', description: 'Metal shader source code' },
          },
          required: ['code'],
        },
      },
    ];
  }

  private async handleCompileShader(args: any) {
    const { code, target = 'air', optimize = false } = args;
    
    try {
      const result = await compileShader(code, { target, optimize });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: result.success,
              outputPath: result.outputPath,
              errors: result.errors,
              warnings: result.warnings,
              compileTime: result.compileTime,
            }, null, 2),
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `Compilation failed: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  private async handlePreviewShader(args: any) {
    const { shaderPath, width = 512, height = 512, time = 0, touchPoint } = args;
    
    try {
      const imageData = await this.preview.renderFrame({
        shaderPath,
        width,
        height,
        uniforms: {
          time,
          touchPoint: touchPoint || { x: 0.5, y: 0.5 },
          resolution: { x: width, y: height },
        },
      });
      
      return {
        content: [
          {
            type: 'image',
            data: imageData.toString('base64'),
            mimeType: 'image/png',
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `Preview failed: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  private async handleUpdateUniforms(args: any) {
    const { uniforms } = args;
    
    this.parameters.updateUniforms(uniforms);
    
    return {
      content: [
        {
          type: 'text',
          text: `Updated ${Object.keys(uniforms).length} uniforms`,
        },
      ],
    };
  }

  private async handleProfilePerformance(args: any) {
    const { shaderPath, iterations = 100, resolution = { width: 512, height: 512 } } = args;
    
    try {
      const metrics = await this.profiler.profileShader({
        shaderPath,
        iterations,
        resolution,
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              averageFrameTime: `${metrics.averageFrameTime.toFixed(2)}ms`,
              fps: metrics.fps.toFixed(1),
              gpuTime: `${metrics.gpuTime.toFixed(2)}ms`,
              cpuTime: `${metrics.cpuTime.toFixed(2)}ms`,
              memoryUsage: `${(metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB`,
              powerUsage: metrics.powerUsage,
            }, null, 2),
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `Profiling failed: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  private async handleHotReload(args: any) {
    const { filePath, enable } = args;
    
    if (enable) {
      await this.hotReload.watch(filePath, async (path) => {
        // Notify about file change
        this.server.notification({
          method: 'shader/changed',
          params: { path },
        });
      });
      
      return {
        content: [
          {
            type: 'text',
            text: `Hot reload enabled for ${filePath}`,
          },
        ],
      };
    } else {
      this.hotReload.unwatch(filePath);
      
      return {
        content: [
          {
            type: 'text',
            text: `Hot reload disabled for ${filePath}`,
          },
        ],
      };
    }
  }

  private async handleValidateShader(args: any) {
    const { code } = args;
    
    try {
      const validation = await validateShader(code);
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              valid: validation.valid,
              errors: validation.errors,
              warnings: validation.warnings,
              suggestions: validation.suggestions,
            }, null, 2),
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `Validation failed: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Metal Shader MCP Server running on stdio');
  }
}

// Start the server
const server = new MetalShaderMCPServer();
server.run().catch(console.error);

// Keep the process alive and handle stdio properly
process.stdin.resume();

// Handle parent process termination (for when launched from Swift)
if (process.argv.includes('--stdio')) {
  // Monitor stdin for EOF (parent process terminated)
  process.stdin.on('end', () => {
    console.error('Parent process terminated, shutting down...');
    process.exit(0);
  });
  
  // Handle SIGINT and SIGTERM gracefully
  process.on('SIGINT', () => {
    console.error('Received SIGINT, shutting down gracefully...');
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    console.error('Received SIGTERM, shutting down gracefully...');
    process.exit(0);
  });
  
  // Prevent uncaught exceptions from crashing
  process.on('uncaughtException', (err) => {
    console.error('Uncaught exception:', err);
  });
  
  process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled rejection at:', promise, 'reason:', reason);
  });
}
```

- **/Users/erichowens/coding/metal-shader-mcp/BUGS.md**
```
# Bug Log & Technical Issues

## Project Status: Fresh Start (2025-09-07)
Starting clean implementation of Metal Shader MCP with three-phase approach.

## Current Issues
*No issues yet - project freshly started*

### 2025-09-08 ‚Äî EPIC auto-comment robustness
- Problem: Post-commit EPIC sync printed `command not found` lines like `build(ci)::` when commits included conventional scopes. The heredoc in the sync script wasn‚Äôt fully protected and quoting was fragile; script also posted to all EPICs indiscriminately.
- Fix:
  - Hardened `scripts/post_commit_sync.sh` with strict tool checks and safe quoting (literal heredoc) to avoid any accidental evaluation of commit text.
  - Added targeted routing via `docs/EPICS_MAP.json` so only relevant EPICs are updated.
- Validation: No more stray shell errors on commit; comments go only to the mapped EPICs.
- Follow-up: Add small mapping tests (see scripts/tests) and consider expanding mappings as codebase grows.

### 2025-09-08 ‚Äî CI and Branch Protection
- Issue: GitHub Actions CI for PRs compiled only ShaderPlayground.swift which referenced types declared in other Swift files (AppShellView, HistoryTabView, SessionRecorder), causing missing-type build failures.
- Also: UI Smoke job errored that `@StateObject` requires `SessionRecorder` to conform to `ObservableObject` due to missing `import SwiftUI` on CI‚Äôs toolchain.
- Fix:
  - Updated workflows to compile all Swift sources: ShaderPlayground.swift AppShellView.swift HistoryTabView.swift SessionRecorder.swift.
  - Added `import SwiftUI` to SessionRecorder.swift so the `StateObject` constraint is satisfied consistently on macOS 15/Swift 6.1.2.
- Validation: All required checks now pass (Build, Tests, Visual Testing, UI Smoke, Docs, WARP).
- Branch Protection: Required review removed (solo maintainer), but all status checks remain required and branches must be up-to-date before merge.
- Workaround/Notes: When adding new Swift files that are part of the app shell, ensure the CI compile step includes them until an Xcode project or SwiftPM target is introduced for automatic file discovery.

### 2025-09-07 ‚Äî GitHub Setup Notes
- No blocking issues encountered while verifying/pushing to GitHub.
- Preventative: Added ignore rules for `MetalShaderStudio`, `*.app`, and `warp_drive_mcp_import.json` to avoid committing binaries and secrets.
- Secrets: Use .env (see .env.example) or shell environment for keys (Brave, HF, Notion, Stability, GitHub). Do not store tokens in repo files.

## Compilation Command
```bash
swiftc -o MetalShaderStudio ShaderPlayground.swift \
  -framework SwiftUI \
  -framework MetalKit \
  -framework AppKit \
  -framework UniformTypeIdentifiers \
  -parse-as-library

./MetalShaderStudio
```

## Debug Strategy
When debugging issues, ALWAYS do a web search first:
- NSTextView editing issues ‚Üí Search StackOverflow
- Process/NSTask issues ‚Üí Search Apple Developer Forums
- Metal compilation ‚Üí Search Metal by Example
- SwiftUI bindings ‚Üí Search SwiftUI labs

## Workflow Integration
- Visual evidence collection system ready
- Screenshot scripts available in scripts/
- Documentation workflow per WARP.md
- Git workflow optimized for iterative development

```

- **/Users/erichowens/coding/metal-shader-mcp/CHANGELOG.md**
```
# Changelog

## [2025-09-09] - CI EPIC Progress Sync

### Changed
- README.md: Added EPIC Progress Sync status badge.

### Added
- New GitHub Actions workflow `.github/workflows/epic-sync.yml` that runs `scripts/post_commit_sync.sh` in CI to post progress comments to EPIC issues.
  - Uses `GITHUB_TOKEN` with `issues: write` permission.
  - Triggers on push to any branch, and on PR opened/synchronize/reopened (non-fork) events.
  - Automatically includes commit URL, short SHA, PR link (when available), changed files, and any screenshot evidence in `Resources/screenshots/`.

### Documentation
- WARP.md updated with a "CI Automation: EPIC Progress Sync" section describing configuration, triggers, and secret handling.

All notable changes to the Metal Shader MCP project will be documented in this file.

## [2025-09-08] - CI stability, EPIC targeting, and branch protection policy updates

### Fixed
- GitHub Actions CI failing due to compiling only a subset of Swift sources. Updated build and visual-test workflows to compile all relevant Swift files (ShaderPlayground.swift, AppShellView.swift, HistoryTabView.swift, SessionRecorder.swift).
- UI Smoke job compile error addressed by adding `import SwiftUI` to `SessionRecorder.swift` to satisfy `@StateObject`‚Äôs `ObservableObject` constraint on macOS 15/Swift 6.1.2.
- SwiftUI macOS compatibility: Replaced `.onChange(of:) { _, new in ... }` with single-argument form to avoid requiring macOS 14+ (keeps macOS 12+ target).
- EPIC sync script robustness: Quoting and targeting fixes eliminate stray shell errors and prevent blanket comments.

### Changed
- Branch protection policy updated for solo maintenance:
  - Removed the ‚Äúrequired PR review‚Äù gate.
  - Kept ‚Äúrequire branches up-to-date‚Äù and ‚Äúall required status checks must pass.‚Äù
  - Admin enforcement remains enabled.

### Notes
- Visual evidence and artifacts are captured in CI runs.
- Future work: migrate to Xcode project or Swift Package for automatic file discovery in CI.
- Added `docs/EPICS_MAP.json` to route EPIC updates by area (UI/UX, State & Workflow, CI/Regression, Library, Core MCP).

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [2025-09-07] - Complete CI/CD Pipeline and Branch Protection Setup

### Added
- **Comprehensive GitHub Actions CI/CD Pipeline**: 5 automated workflows for complete quality assurance
  - `swift-build.yml`: Swift/Metal compilation validation on macOS runners
  - `documentation.yml`: Markdown syntax, link validation, and documentation quality checks
  - `visual-tests.yml`: Visual evidence capture, screenshot optimization, and regression testing framework
  - `test.yml`: Swift unit tests, shader parameter validation, and quality assurance metrics
  - `warp-compliance.yml`: WARP protocol adherence validation with automated compliance reporting

- **Branch Protection Configuration**: Secure main branch with comprehensive protection rules
  - Require pull request reviews (minimum 1 approval)
  - Dismiss stale reviews on new commits
  - Require all status checks to pass before merging
  - Enforce for administrators
  - Block direct pushes and force pushes
  - Require branches to be up to date before merging

- **Workflow Configuration Files**:
  - `.github/markdownlint.json`: Markdown linting rules optimized for technical documentation
  - `.github/markdown-link-check.json`: Link validation configuration with proper timeout and retry settings
  - `.github/CONTRIBUTING.md`: Complete 270+ line development guide with workflow documentation

- **WARP Protocol Automation**:
  - Automatic BUGS.md and CHANGELOG.md validation for every commit
  - Visual evidence requirement enforcement for UI/shader changes
  - Conventional commit format checking and compliance reporting
  - After-action requirements verification with detailed reporting

- **Quality Assurance Features**:
  - Automated Metal shader compilation testing across all `.metal` files
  - Visual evidence capture with WARP-compliant naming conventions (`YYYY-MM-DD_HH-MM-SS_description.png`)
  - Documentation consistency validation and broken link detection
  - Test coverage reporting and quality metrics collection
  - Cross-platform workflow execution (macOS for Metal, Ubuntu for documentation)
  - Artifact storage with configurable retention periods (7-30 days)
  - Workflow status badges added to README.md for real-time CI/CD visibility

### Enhanced
- **Development Workflow**: All changes now require pull requests with automated quality gates
- **Documentation Quality**: Automated validation ensures all documentation meets standards
- **Visual Evidence**: Systematic capture and validation of visual changes per WARP protocol
- **Testing Framework**: Foundation for comprehensive Swift unit tests and visual regression testing
- **Compliance Monitoring**: Continuous validation of workflow protocol adherence

### Infrastructure
- **GitHub Actions Runners**: 
  - macOS-latest for Swift/Metal compilation and visual testing
  - Ubuntu-latest for documentation validation and compliance checking
- **Dependency Management**: Automated caching for Swift packages and Node.js dependencies
- **Artifact Management**: Structured storage for build artifacts, test reports, and visual evidence
- **Notification System**: Workflow failure notifications and status reporting

### Security
- **Branch Protection**: Prevents unauthorized direct changes to main branch
- **Review Requirements**: Ensures all changes undergo code review process
- **Status Check Enforcement**: Blocks merges that fail quality gates
- **Administrator Enforcement**: No exceptions for administrative users

### Visual Evidence
- GitHub Actions workflows successfully configured and operational
- Branch protection rules active and preventing direct pushes
- Workflow status badges displaying real-time CI/CD status
- Complete development workflow documentation in CONTRIBUTING.md
- All workflows follow WARP protocol for visual evidence and documentation requirements

### Notes
- Initial workflow setup required temporary branch protection removal for bootstrap push
- All subsequent changes must go through pull request process
- Workflows will establish baseline visual evidence on first successful runs
- CI/CD pipeline ready for immediate use in development workflow

## [2025-09-07] - GitHub Setup and Repo Hygiene

### Changed
- Verified Git remote: origin -> https://github.com/erichowens/metal-shader-mcp.git
- Pushed pending local commits on main to origin (was ahead by +3)
- Updated .gitignore to exclude local app binary (MetalShaderStudio), macOS app bundles (*.app), and secret-laden config (warp_drive_mcp_import.json)

### Security
- Ensured secrets are not tracked in Git. Store keys in .env or your shell env. See .env.example for sources and variable names.
- warp_drive_mcp_import.json kept untracked; contains local paths and env placeholders.

### Visual Evidence
- N/A (no UI/shader changes).

## [2025-09-07] - REPL Plan, UI Design, Pragmatic Docs, and Sync Hooks

### Added
- **REPL-focused MCP tool roadmap** prioritized for Claude‚Äôs visual learning
- **EPIC: SwiftUI App UI/UX + Educational Library** with persistence plan
- **DESIGN.md**: Wireframes, user stories, view hierarchy, persistence model
- **CLAUDE.md** rewritten as pragmatic REPL guide aligned with WARP.md
- Updated internal todos to reflect new EPICs and priorities

### Notes
- Added post-commit sync hook (local) that posts progress comments to EPIC issues via gh CLI
- Provide scripts/install_hooks.sh to install hooks locally (git does not version-control hooks)
- Nightly smoke test planned to render a canonical shader and catch breakage

### Changed
- **WARP.md Workflow Protocol**: Consolidated multi-agent workflow into single-agent responsibilities
- Updated compilation commands to reflect ShaderPlayground.swift as main application file
- Revised workflow timing expectations to be realistic for single-agent execution (5-10 minutes for complex changes)
- Reorganized agent responsibilities into cohesive categories: Code Review & Quality, Documentation, Task Management, Metal Shader Specific

### Removed
- Deleted agent-orchestrator.ts - unnecessary complexity, Warp already provides orchestration
- Removed fake "agent" abstractions that provided no real value
- Eliminated references to multiple agents in WARP.md workflow documentation

## [Unreleased]

### Fixed
- **Critical UI Synchronization**: Fixed shader library loading appearing empty
- **Text Editor Empty Content**: Fixed code editor showing blank when switching tabs
- **Tab Selection Sync**: Fixed selectedTab state not synchronized between components
- **Compilation Target**: Fixed compileCurrentShader() always targeting first tab instead of selected tab
- **Auto-compilation**: Fixed missing auto-compilation on text changes and library loading
- **Library Loading**: Fixed shader library items not appearing to load due to UI sync issues

### Added
- **Advanced Error Detection System**: Comprehensive real-time error detection with syntax validation
- **Enhanced Code Editor**: Professional code editor with syntax highlighting, error overlays, and tooltips
- **Intelligent Error Panel**: Dedicated error panel with filtering, search, and detailed error information
- **Visual Testing Framework**: Automated screenshot capture and visual regression testing system
- **Error Recovery Engine**: Intelligent suggestions and automated fixes for common shader errors
- **Real-time Validation**: Live syntax checking as user types with immediate feedback
- Comprehensive workflow documentation in WARP.md
- Creative workflow integration in CLAUDE.md  
- Visual testing framework requirements in VISUAL_TESTING.md
- Agent-based development process
- Automated screenshot capture and visual diff scripts
- Directory structure for visual evidence collection
- Integration of artistic workflow with technical validation
- Multi-agent coordination protocols

### Enhanced
- **Error Detection Engine**: Advanced Metal shader syntax analysis with detailed error categorization
- **Code Highlighting**: Sophisticated syntax highlighting with Metal-specific keywords and functions
- **Error Recovery**: Automated fix suggestions with intelligent error pattern recognition
- **User Experience**: Hover tooltips, error navigation, and contextual help for shader development
- **Visual Validation**: Screenshot-based testing for UI consistency and regression prevention
- README.md updated with workflow requirements
- BUGS.md expanded with resolution tracking
- Documentation consistency across all .md files
- Git workflow optimized for creative development
- Cleaned up redundant/broken scripts - only working ones remain

### Infrastructure
- **New Core Components**:
  - `ErrorDetectionEngine.swift` - Advanced error detection and analysis system
  - `CodeEditor.swift` - Professional code editor with syntax highlighting and error overlays
  - `ErrorPanel.swift` - Comprehensive error management UI component
  - `VisualTestingFramework.swift` - Automated visual testing and regression detection
- **Enhanced Models**: Extended `CompilationError` with detailed error context, severity levels, and suggestions
- **Real-time Processing**: Debounced syntax validation with intelligent error categorization
- `scripts/screenshot_app.sh` - Bulletproof window capture using CGWindowID
- `scripts/find_window_id.py` - Swift-powered visible window detection
- `scripts/debug_window.py` - Window debugging utility (optional)
- `Resources/screenshots/` directory structure established

### Visual Evidence
- **Error Detection System**: Visual evidence captured showing enhanced error highlighting and tooltips
- **Code Editor**: Screenshots demonstrating syntax highlighting, error overlays, and real-time validation
- **Error Panel**: Visual documentation of comprehensive error management interface
- **Testing Framework**: Automated screenshot capture system for regression testing
- **User Experience**: Before/after comparisons showing improved developer workflow
- Workflow documentation system fully operational
- Agent coordination protocols defined and documented
- Visual testing framework ready for implementation
- All documentation files consistent and cross-referenced

## [0.1.0] - 2024-09-06

### Added
- Initial Metal Shader Studio application with SwiftUI interface
- Basic shader compilation and rendering system
- Parameter extraction and manipulation capabilities
- Shader library with basic plasma and kaleidoscope effects
- MCP server integration for AI-assisted shader development
- Real-time shader editing with syntax highlighting
- Export functionality framework (PNG, video)

### Core Components
- `MetalStudioMCPEnhanced.swift`: Main application interface
- `MetalStudioMCPCore.swift`: Core rendering and Metal integration  
- `MetalStudioMCPModels.swift`: Data models and shader management
- `MetalStudioMCPComponents.swift`: UI components and parameter controls
- Shader library: plasma, kaleidoscope, fractals, and procedural patterns

### Infrastructure  
- Xcode project configuration for macOS development
- Git repository with proper .gitignore for Xcode/Swift projects
- Build scripts and compilation toolchain setup
- Node.js MCP server implementation
- TypeScript integration for extended functionality

### Documentation
- README.md with project overview and setup instructions
- CLAUDE.md with creative vision and AI interaction patterns
- BUGS.md for tracking technical issues and solutions
- Setup and implementation guides

### Known Issues
- Text editor keyboard input intermittent
- MCP server connection stability needs improvement
- Export functionality requires full implementation
- Visual testing framework not yet implemented

### Visual Evidence
- Project structure and basic UI established
- Shader compilation and rendering pipeline functional
- Parameter manipulation system operational
- Library loading and shader switching working

---

## Change Categories

### Added
- New features, functionality, or components

### Changed  
- Changes in existing functionality or behavior

### Deprecated
- Soon-to-be removed features

### Removed
- Removed features or components

### Fixed
- Bug fixes and issue resolutions

### Security
- Vulnerability fixes and security improvements

### Visual
- UI changes, shader modifications, visual improvements

### Performance
- Performance improvements and optimizations

---

*This changelog documents the evolution of the Metal Shader MCP from concept to functional creative tool, tracking both technical progress and artistic development.*

```

- **/Users/erichowens/coding/metal-shader-mcp/README.md**
```
# Metal Shader MCP - Claude's Shader Development Playground

[![Swift/Metal Build](https://github.com/erichowens/metal-shader-mcp/actions/workflows/swift-build.yml/badge.svg)](https://github.com/erichowens/metal-shader-mcp/actions/workflows/swift-build.yml)
[![Tests](https://github.com/erichowens/metal-shader-mcp/actions/workflows/test.yml/badge.svg)](https://github.com/erichowens/metal-shader-mcp/actions/workflows/test.yml)
[![Documentation](https://github.com/erichowens/metal-shader-mcp/actions/workflows/documentation.yml/badge.svg)](https://github.com/erichowens/metal-shader-mcp/actions/workflows/documentation.yml)
[![Visual Tests](https://github.com/erichowens/metal-shader-mcp/actions/workflows/visual-tests.yml/badge.svg)](https://github.com/erichowens/metal-shader-mcp/actions/workflows/visual-tests.yml)
[![WARP Compliance](https://github.com/erichowens/metal-shader-mcp/actions/workflows/warp-compliance.yml/badge.svg)](https://github.com/erichowens/metal-shader-mcp/actions/workflows/warp-compliance.yml)
[![EPIC Progress Sync](https://github.com/erichowens/metal-shader-mcp/actions/workflows/epic-sync.yml/badge.svg?branch=main)](https://github.com/erichowens/metal-shader-mcp/actions/workflows/epic-sync.yml)

A complete system for AI-assisted Metal shader development where Claude can write, modify, and visually iterate on shaders in real-time.

## Project overview
Metal Shader MCP is a macOS SwiftUI + Metal playground with a disciplined workflow for shader iteration, visual evidence, and CI. An MCP layer is planned to let AI assistants interact with the app (compile, preview, snapshot), but today the primary entry point is the macOS app you can compile and run locally.

## Current state (as of 2025-09-08)
- macOS app (SwiftUI + Metal) builds and runs locally and in CI.
- Live shader editing with a simple renderer and screenshot/export helpers.
- Session Browser (History tab) captures per-session snapshots (code + image + meta).
- CI enforces: build, tests, visual-evidence capture, WARP workflow compliance, UI smoke (tab selection/status), docs checks.
- Branch protection requires all status checks to pass and branches to be up-to-date (no required external review since this is solo-maintained).

## Roadmap
- MCP server integration to drive the macOS app (compile/preview/snapshot) from tools.
- Visual regression tests with baselines across multiple resolutions.
- Shader library with names, descriptions, and persistent metadata (see WARP/metadata rules).
- Export pipelines (PNG/video) with parameter sweeps and performance profiling.
- Xcode project or Swift Package targets for automatic file discovery in CI.

## Quick start (macOS app)
- Prereqs: macOS with Xcode (latest stable), Metal-capable device.
- Build and run locally:

```bash
swiftc -o MetalShaderStudio \
  ShaderPlayground.swift AppShellView.swift HistoryTabView.swift SessionRecorder.swift \
  -framework SwiftUI -framework MetalKit -framework AppKit -framework UniformTypeIdentifiers \
  -parse-as-library

./MetalShaderStudio --tab history
```

## Features

- **Live Compilation**: Compile Metal shaders in real-time with error reporting
- **Hot Reload**: Automatic recompilation on file changes
- **Performance Profiling**: Measure FPS, GPU/CPU time, and memory usage
- **Preview Engine**: Real-time shader preview with WebSocket updates
- **Shader Templates**: Built-in shader examples and effects
- **MCP Integration**: Seamless integration with AI assistants

## Installation

- macOS app (current): see Quick start above.
- MCP server (planned): the existing npm scripts are placeholders for the future MCP server. They are not required to run the macOS app today.

```bash
# Planned (MCP server), not required for the macOS app today
npm install
npm run build
```

## Usage

### Start MCP Server

```bash
npm start
```

### Development Mode

```bash
npm run dev
```

### Available MCP Tools

1. **compile_shader**: Compile Metal shader code
   - Supports AIR, metallib, and SPIRV targets
   - Optimization options
   - Error and warning reporting

2. **preview_shader**: Generate preview images
   - Real-time rendering
   - Customizable resolution
   - Touch interaction support

3. **update_uniforms**: Update shader parameters
   - Time, touch position, resolution
   - Custom uniform values

4. **profile_performance**: Performance metrics
   - FPS measurement
   - GPU/CPU time tracking
   - Memory usage monitoring

5. **hot_reload**: File watching
   - Automatic recompilation
   - WebSocket notifications
   - Development dashboard

6. **validate_shader**: Syntax validation
   - Error detection
   - Performance suggestions
   - Code analysis

## Shader Development

### Example: Kaleidoscope Effect

```metal
#include <metal_stdlib>
using namespace metal;

fragment float4 kaleidoscopeFragment(
    VertexOut in [[stage_in]],
    texture2d<float> texture [[texture(0)]],
    constant Uniforms& uniforms [[buffer(0)]]
) {
    // Kaleidoscope transformation
    float2 uv = kaleidoscope(in.texCoord, 6, uniforms.time);
    
    // Generate RGBY color blocks
    float4 color = generateColorBlock(uv, uniforms.blockSize);
    
    return color;
}
```

### Performance Requirements

- **Target**: 60fps on modern devices
- **Memory**: Efficient memory usage
- **Compilation**: <500ms

## Architecture

```
metal-shader-mcp/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts         # MCP server
‚îÇ   ‚îú‚îÄ‚îÄ compiler.ts      # Metal compilation
‚îÇ   ‚îú‚îÄ‚îÄ preview.ts       # Preview engine
‚îÇ   ‚îú‚îÄ‚îÄ hotReload.ts     # File watching
‚îÇ   ‚îú‚îÄ‚îÄ profiler.ts      # Performance profiling
‚îÇ   ‚îî‚îÄ‚îÄ parameters.ts    # Uniform management
‚îú‚îÄ‚îÄ shaders/
‚îÇ   ‚îî‚îÄ‚îÄ kaleidoscope.metal  # Example shader
‚îî‚îÄ‚îÄ dist/                # Compiled output
```

## Hot Reload Dashboard

Access the development dashboard at:
```
http://localhost:3000/dashboard
```

Features:
- Real-time compilation status
- Error and warning display
- Performance metrics
- File watching status

## Shader Examples

The included kaleidoscope shader demonstrates:
- Real-time geometric transformations
- Perlin noise generation
- Color block effects
- Interactive animations
- Performance optimization techniques

## Performance Optimization

The profiler measures:
- Average frame time
- Frames per second
- GPU processing time
- CPU overhead
- Memory usage
- Power consumption estimate

## Development Workflow

### After-Action Requirements
Every significant development action must complete these steps:

1. **Update BUGS.md** - Document any issues discovered
2. **Update CHANGELOG.md** - Record what was accomplished  
3. **Capture Visual Evidence** - Screenshots for UI/shader changes
4. **Run Tests** - Ensure no regressions introduced
5. **Git Operations** - Commit with descriptive messages

See `WARP.md` for detailed workflow documentation.

### Visual Testing
This project uses visual evidence collection for shader development:

```bash
# Capture screenshots of current state
./scripts/screenshot_app.sh "feature_description"

# Debug window capture issues
python3 scripts/debug_window.py

# Run visual tests (when implemented)
swift test --filter VisualRegressionTests
```

### Documentation Files
- **WARP.md** - Agent workflow requirements
- **CLAUDE.md** - Creative vision and AI interaction patterns
- **VISUAL_TESTING.md** - Visual testing framework
- **BUGS.md** - Current issues and solutions
- **CHANGELOG.md** - Project evolution history

## Contributing

Contributions are welcome! Please follow the workflow requirements in `WARP.md`:

1. Create feature branch from main
2. Implement changes with visual evidence
3. Update relevant documentation
4. Run visual regression tests
5. Submit pull request with screenshots

## License

MIT

```





**File Glob Results:**

- **/Users/erichowens/coding/metal-shader-mcp/.env.example**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/documentation.yml**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/epic-sync.yml**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/swift-build.yml**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/test.yml**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/ui-smoke.yml**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/visual-tests.yml**
- **/Users/erichowens/coding/metal-shader-mcp/.github/workflows/warp-compliance.yml**
- **/Users/erichowens/coding/metal-shader-mcp/AppShellView.swift**
- **/Users/erichowens/coding/metal-shader-mcp/HistoryTabView.swift**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_05-32-05_debug_test.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_05-44-36_bulletproof_test.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_19-56-18_final_verification.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_19-58-01_actually_working_test.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_19-58-15_final_working_test.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_20-06-47_cleanup_verification.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_20-55-21_current_ui_bugs_shader_editor_empty.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-06_21-01-54_after_ui_bug_fixes_shader_editor_working.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_01-20-12_test_shader_app.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_01-26-06_mcp_test_current_state.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_05-32-25_successful_mcp_shader_test.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_08-39-19_uniforms_override_test_export.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_10-38-28_cicd_setup_status.txt**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_14-08-20_current_tool_ui.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_14-17-01_history_tab.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_14-35-36_history_compare_ui.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_14-38-41_history_tab_open.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_14-58-18_history_tab_open_verified.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_14-58-53_history_tab_after_set_tab.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_15-04-43_history_tab_verify_correct_tab.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/2025-09-07_15-12-04_history_tab_checked.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/20250906_022715_workflow_implementation_complete.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/20250906_035110_metal_shader_studio_fixed_layout.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/20250906_040055_metal_shader_studio_front_window.png**
- **/Users/erichowens/coding/metal-shader-mcp/Resources/screenshots/20250906_040718_current_desktop.png**
- **/Users/erichowens/coding/metal-shader-mcp/SessionRecorder.swift**
- **/Users/erichowens/coding/metal-shader-mcp/WARP.md**
- **/Users/erichowens/coding/metal-shader-mcp/compile.sh**
- **/Users/erichowens/coding/metal-shader-mcp/docs/EPICS.json**
- **/Users/erichowens/coding/metal-shader-mcp/docs/EPICS_MAP.json**
- **/Users/erichowens/coding/metal-shader-mcp/package.json**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/ci/ui_smoke.sh**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/debug_window.py**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/find_window_id.py**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/install_hooks.sh**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/post_commit_sync.sh**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/screenshot_app.sh**
- **/Users/erichowens/coding/metal-shader-mcp/scripts/set_tab.sh**
- **/Users/erichowens/coding/metal-shader-mcp/src/compiler.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/hot-reload.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/hotReload.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/index.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/param-extractor.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/parameters.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/preview.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/profiler.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/shader-library.ts**
- **/Users/erichowens/coding/metal-shader-mcp/src/simple-mcp.ts**
- **/Users/erichowens/coding/metal-shader-mcp/tsconfig.json**




**Files Read:**

**/Users/erichowens/coding/metal-shader-mcp/package.json**
```
{
  "name": "metal-shader-mcp",
  "version": "1.0.0",
  "description": "Model Context Protocol server for live Metal shader development",
  "main": "dist/index.js",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsx watch src/index.ts",
    "test": "jest",
    "compile-shader": "xcrun -sdk macosx metal -c",
    "mcp": "stdio"
  },
  "keywords": [
    "mcp",
    "metal",
    "shader",
    "webgpu",
    "graphics"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "chokidar": "^3.6.0",
    "express": "^4.18.0",
    "ws": "^8.16.0",
    "sharp": "^0.33.0",
    "tmp": "^0.2.1"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/express": "^4.17.0",
    "@types/ws": "^8.5.0",
    "@types/tmp": "^0.2.0",
    "typescript": "^5.3.0",
    "tsx": "^4.7.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.0"
  },
  "mcp": {
    "name": "Metal Shader MCP",
    "description": "Live Metal shader development and preview",
    "version": "1.0.0",
    "transport": "stdio",
    "tools": [
      "compile_shader",
      "preview_shader",
      "update_uniforms",
      "profile_performance",
      "hot_reload"
    ]
  }
}
```





**Files Read:**

**/Users/erichowens/coding/metal-shader-mcp/src/preview.ts**
```
/**
 * Metal Shader Preview Engine
 * Renders shader output to images or live preview
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import sharp from 'sharp';
import crypto from 'crypto';

const execAsync = promisify(exec);

export interface RenderOptions {
  shaderPath: string;
  width: number;
  height: number;
  uniforms: Record<string, any>;
  format?: 'png' | 'jpeg' | 'webp';
}

export interface PreviewServer {
  port: number;
  url: string;
  stop: () => Promise<void>;
}

export class PreviewEngine {
  private previewServer?: PreviewServer;
  private renderCache: Map<string, Buffer> = new Map();
  
  /**
   * Render a single frame using the compiled shader
   */
  async renderFrame(options: RenderOptions): Promise<Buffer> {
    const { shaderPath, width, height, uniforms, format = 'png' } = options;
    
    // Generate cache key
    const cacheKey = this.generateCacheKey(options);
    if (this.renderCache.has(cacheKey)) {
      return this.renderCache.get(cacheKey)!;
    }
    
    // Create temporary render program
    const hash = crypto.createHash('md5').update(cacheKey).digest('hex');
    const tempDir = path.join(os.tmpdir(), 'metal-shader-preview', hash);
    await fs.mkdir(tempDir, { recursive: true });
    
    try {
      // Generate Metal render program
      const renderProgram = this.generateRenderProgram(uniforms);
      const programPath = path.join(tempDir, 'render.swift');
      await fs.writeFile(programPath, renderProgram);
      
      // Compile and run the render program
      const outputPath = path.join(tempDir, `output.${format}`);
      const compileCmd = `swiftc -O -o ${path.join(tempDir, 'render')} ${programPath}`;
      await execAsync(compileCmd);
      
      const runCmd = `${path.join(tempDir, 'render')} ${shaderPath} ${width} ${height} ${outputPath}`;
      await execAsync(runCmd);
      
      // Read and cache the output
      const imageBuffer = await fs.readFile(outputPath);
      
      // Process with sharp if needed
      const processedBuffer = await sharp(imageBuffer)
        .resize(width, height, { fit: 'contain' })
        .toFormat(format)
        .toBuffer();
      
      this.renderCache.set(cacheKey, processedBuffer);
      
      // Cleanup temp files
      await fs.rm(tempDir, { recursive: true, force: true });
      
      return processedBuffer;
      
    } catch (error) {
      // Cleanup on error
      await fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});
      throw error;
    }
  }
  
  /**
   * Start a live preview server
   */
  async startPreviewServer(port: number = 8080): Promise<PreviewServer> {
    const express = await import('express');
    const { WebSocketServer } = await import('ws');
    
    const app = express.default();
    const server = app.listen(port);
    const wss = new WebSocketServer({ server });
    
    // Serve preview page
    app.get('/', (req, res) => {
      res.send(this.getPreviewHTML());
    });
    
    // Serve rendered frames
    app.get('/frame/:id', async (req, res) => {
      const frameId = req.params.id;
      if (this.renderCache.has(frameId)) {
        const buffer = this.renderCache.get(frameId)!;
        res.type('image/png').send(buffer);
      } else {
        res.status(404).send('Frame not found');
      }
    });
    
    // WebSocket for live updates
    wss.on('connection', (ws) => {
      ws.on('message', async (message) => {
        try {
          const data = JSON.parse(message.toString());
          if (data.type === 'render') {
            const buffer = await this.renderFrame(data.options);
            ws.send(JSON.stringify({
              type: 'frame',
              data: buffer.toString('base64'),
            }));
          }
        } catch (error: any) {
          ws.send(JSON.stringify({
            type: 'error',
            message: error.message,
          }));
        }
      });
    });
    
    this.previewServer = {
      port,
      url: `http://localhost:${port}`,
      stop: async () => {
        wss.close();
        await new Promise((resolve) => server.close(resolve));
      },
    };
    
    return this.previewServer;
  }
  
  /**
   * Stop the preview server
   */
  async stopPreviewServer(): Promise<void> {
    if (this.previewServer) {
      await this.previewServer.stop();
      this.previewServer = undefined;
    }
  }
  
  /**
   * Generate Swift program for rendering
   */
  private generateRenderProgram(uniforms: Record<string, any>): string {
    return `
import Metal
import MetalKit
import CoreImage
import AppKit

// Command line arguments
let args = CommandLine.arguments
guard args.count >= 5 else {
    print("Usage: render <shader.metallib> <width> <height> <output.png>")
    exit(1)
}

let shaderPath = args[1]
let width = Int(args[2]) ?? 512
let height = Int(args[3]) ?? 512
let outputPath = args[4]

// Setup Metal
guard let device = MTLCreateSystemDefaultDevice() else {
    print("Metal is not supported")
    exit(1)
}

let commandQueue = device.makeCommandQueue()!
let library = try! device.makeLibrary(filepath: shaderPath)

// Create render pipeline
let pipelineDescriptor = MTLRenderPipelineDescriptor()
pipelineDescriptor.vertexFunction = library.makeFunction(name: "vertexShader")
pipelineDescriptor.fragmentFunction = library.makeFunction(name: "fragmentShader")
pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm

let pipelineState = try! device.makeRenderPipelineState(descriptor: pipelineDescriptor)

// Create texture
let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(
    pixelFormat: .bgra8Unorm,
    width: width,
    height: height,
    mipmapped: false
)
textureDescriptor.usage = [.renderTarget, .shaderRead]
let texture = device.makeTexture(descriptor: textureDescriptor)!

// Setup uniforms
struct Uniforms {
    var time: Float = ${uniforms.time || 0}
    var resolution: SIMD2<Float> = SIMD2<Float>(Float(${uniforms.resolution?.x || 'width'}), Float(${uniforms.resolution?.y || 'height'}))
    var touchPoint: SIMD2<Float> = SIMD2<Float>(${uniforms.touchPoint?.x || 0.5}, ${uniforms.touchPoint?.y || 0.5})
}

var uniformData = Uniforms()
let uniformBuffer = device.makeBuffer(bytes: &uniformData, length: MemoryLayout<Uniforms>.size, options: [])

// Render
let renderPassDescriptor = MTLRenderPassDescriptor()
renderPassDescriptor.colorAttachments[0].texture = texture
renderPassDescriptor.colorAttachments[0].loadAction = .clear
renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 1)
renderPassDescriptor.colorAttachments[0].storeAction = .store

let commandBuffer = commandQueue.makeCommandBuffer()!
let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!

renderEncoder.setRenderPipelineState(pipelineState)
renderEncoder.setFragmentBuffer(uniformBuffer, offset: 0, index: 0)
renderEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
renderEncoder.endEncoding()

commandBuffer.commit()
commandBuffer.waitUntilCompleted()

// Export to image
let ciImage = CIImage(mtlTexture: texture, options: nil)!
let ciContext = CIContext(mtlDevice: device)
let cgImage = ciContext.createCGImage(ciImage, from: ciImage.extent)!

let url = URL(fileURLWithPath: outputPath)
let destination = CGImageDestinationCreateWithURL(url as CFURL, kUTTypePNG, 1, nil)!
CGImageDestinationAddImage(destination, cgImage, nil)
CGImageDestinationFinalize(destination)

print("Rendered to \\(outputPath)")
`;
  }
  
  /**
   * Generate cache key for render options
   */
  private generateCacheKey(options: RenderOptions): string {
    const keyData = {
      shader: options.shaderPath,
      width: options.width,
      height: options.height,
      uniforms: options.uniforms,
      format: options.format,
    };
    return crypto
      .createHash('md5')
      .update(JSON.stringify(keyData))
      .digest('hex');
  }
  
  /**
   * Get HTML for preview page
   */
  private getPreviewHTML(): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>Metal Shader Preview</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .preview {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        #canvas {
            width: 100%;
            height: 600px;
            background: #000;
            border-radius: 8px;
        }
        
        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .control {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            color: #666;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: white;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status.connected {
            background: #4CAF50;
            color: white;
        }
        
        .status.disconnected {
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="color: white; text-align: center;">Metal Shader Live Preview</h1>
        
        <div class="preview">
            <canvas id="canvas"></canvas>
            
            <div class="controls">
                <div class="control">
                    <label>Time</label>
                    <input type="range" id="time" min="0" max="1" step="0.01" value="0">
                </div>
                
                <div class="control">
                    <label>Touch X</label>
                    <input type="range" id="touchX" min="0" max="1" step="0.01" value="0.5">
                </div>
                
                <div class="control">
                    <label>Touch Y</label>
                    <input type="range" id="touchY" min="0" max="1" step="0.01" value="0.5">
                </div>
            </div>
        </div>
    </div>
    
    <div class="status" id="status">Disconnected</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        // WebSocket connection
        const ws = new WebSocket('ws://localhost:8080');
        
        ws.onopen = () => {
            status.textContent = 'Connected';
            status.className = 'status connected';
            requestRender();
        };
        
        ws.onclose = () => {
            status.textContent = 'Disconnected';
            status.className = 'status disconnected';
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            if (data.type === 'frame') {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
                img.src = 'data:image/png;base64,' + data.data;
            } else if (data.type === 'error') {
                console.error('Render error:', data.message);
            }
        };
        
        // Controls
        let renderTimeout;
        function requestRender() {
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                const options = {
                    width: canvas.width,
                    height: canvas.height,
                    uniforms: {
                        time: parseFloat(document.getElementById('time').value),
                        touchPoint: {
                            x: parseFloat(document.getElementById('touchX').value),
                            y: parseFloat(document.getElementById('touchY').value),
                        },
                        resolution: {
                            x: canvas.width,
                            y: canvas.height,
                        },
                    },
                };
                
                ws.send(JSON.stringify({
                    type: 'render',
                    options: options,
                }));
            }, 50);
        }
        
        // Bind controls
        document.getElementById('time').addEventListener('input', requestRender);
        document.getElementById('touchX').addEventListener('input', requestRender);
        document.getElementById('touchY').addEventListener('input', requestRender);
        
        // Canvas setup
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            requestRender();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
`;
  }
}
```

**/Users/erichowens/coding/metal-shader-mcp/src/compiler.ts**
```
/**
 * Metal Shader Compiler
 * Handles compilation of Metal shaders using xcrun
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import * as crypto from 'crypto';

const execAsync = promisify(exec);

export interface CompilationResult {
  success: boolean;
  outputPath?: string;
  errors: CompilationError[];
  warnings: CompilationWarning[];
  compileTime: number;
}

export interface CompilationError {
  line: number;
  column: number;
  message: string;
  code?: string;
}

export interface CompilationWarning {
  line: number;
  column: number;
  message: string;
}

export interface CompilationOptions {
  target: 'air' | 'metallib' | 'spirv';
  optimize: boolean;
  includePaths?: string[];
}

export interface ValidationResult {
  valid: boolean;
  errors: CompilationError[];
  warnings: CompilationWarning[];
  suggestions: string[];
}

/**
 * Compile Metal shader code
 */
export async function compileShader(
  code: string,
  options: CompilationOptions = { target: 'air', optimize: false }
): Promise<CompilationResult> {
  const startTime = Date.now();
  const hash = crypto.createHash('md5').update(code).digest('hex');
  const tempDir = path.join(os.tmpdir(), 'metal-shader-mcp', hash);
  
  await fs.mkdir(tempDir, { recursive: true });
  
  const sourcePath = path.join(tempDir, 'shader.metal');
  const outputPath = path.join(tempDir, `shader.${options.target}`);
  
  try {
    // Write source code to temp file
    await fs.writeFile(sourcePath, code);
    
    // Build compilation command
    let command = `xcrun -sdk macosx metal`;
    
    // Add compilation flags
    if (options.optimize) {
      command += ' -O3';
    }
    
    // Add include paths
    if (options.includePaths) {
      for (const includePath of options.includePaths) {
        command += ` -I ${includePath}`;
      }
    }
    
    // Set target format
    switch (options.target) {
      case 'air':
        command += ` -c ${sourcePath} -o ${outputPath}`;
        break;
      case 'metallib':
        // First compile to AIR, then create metallib
        const airPath = path.join(tempDir, 'shader.air');
        command += ` -c ${sourcePath} -o ${airPath}`;
        const { stderr: airErr } = await execAsync(command);
        if (airErr) {
          return parseCompilationResult(airErr, false, Date.now() - startTime);
        }
        command = `xcrun -sdk macosx metallib ${airPath} -o ${outputPath}`;
        break;
      case 'spirv':
        // Metal to SPIR-V requires additional tooling
        command += ` -c ${sourcePath} -o ${outputPath}.air`;
        // Note: Would need spirv-cross or similar for full conversion
        break;
    }
    
    // Execute compilation
    const { stdout, stderr } = await execAsync(command);
    
    // Check if output file was created
    const outputExists = await fs.access(outputPath).then(() => true).catch(() => false);
    
    if (!outputExists && !stderr) {
      throw new Error('Compilation produced no output');
    }
    
    // Parse compiler output
    const result = parseCompilationResult(stderr || '', outputExists, Date.now() - startTime);
    if (outputExists) {
      result.outputPath = outputPath;
    }
    
    return result;
    
  } catch (error: any) {
    // Handle compilation errors
    if (error.stderr) {
      return parseCompilationResult(error.stderr, false, Date.now() - startTime);
    }
    throw error;
  }
}

/**
 * Validate Metal shader syntax
 */
export async function validateShader(code: string): Promise<ValidationResult> {
  const result: ValidationResult = {
    valid: true,
    errors: [],
    warnings: [],
    suggestions: [],
  };
  
  // Check for common Metal shader patterns
  const checks = [
    {
      pattern: /\bfragment\s+\w+\s+\w+\s*\(/,
      message: 'Fragment function detected',
      type: 'info',
    },
    {
      pattern: /\bvertex\s+\w+\s+\w+\s*\(/,
      message: 'Vertex function detected',
      type: 'info',
    },
    {
      pattern: /\[\[stage_in\]\]/,
      message: 'Stage input attribute found',
      type: 'info',
    },
    {
      pattern: /\[\[buffer\(\d+\)\]\]/,
      message: 'Buffer binding found',
      type: 'info',
    },
    {
      pattern: /\[\[texture\(\d+\)\]\]/,
      message: 'Texture binding found',
      type: 'info',
    },
  ];
  
  // Performance suggestions
  if (code.includes('for') && code.includes('for')) {
    result.suggestions.push('Consider unrolling nested loops for better performance');
  }
  
  if (code.includes('pow(')) {
    result.suggestions.push('Consider using multiplication instead of pow() for small exponents');
  }
  
  if (code.includes('sin(') || code.includes('cos(')) {
    result.suggestions.push('Consider using fast math approximations for trigonometric functions if precision is not critical');
  }
  
  // Try actual compilation for full validation
  try {
    const compilationResult = await compileShader(code, { target: 'air', optimize: false });
    result.valid = compilationResult.success;
    result.errors = compilationResult.errors;
    result.warnings = compilationResult.warnings;
  } catch (error) {
    result.valid = false;
    result.errors.push({
      line: 0,
      column: 0,
      message: `Validation error: ${error}`,
    });
  }
  
  return result;
}

/**
 * Parse compiler output for errors and warnings
 */
function parseCompilationResult(
  output: string,
  success: boolean,
  compileTime: number
): CompilationResult {
  const errors: CompilationError[] = [];
  const warnings: CompilationWarning[] = [];
  
  const lines = output.split('\n');
  
  for (const line of lines) {
    // Parse Metal compiler error format
    // Example: shader.metal:10:5: error: use of undeclared identifier 'foo'
    const errorMatch = line.match(/^(.+):(\d+):(\d+):\s*error:\s*(.+)$/);
    if (errorMatch) {
      errors.push({
        line: parseInt(errorMatch[2], 10),
        column: parseInt(errorMatch[3], 10),
        message: errorMatch[4],
      });
      continue;
    }
    
    // Parse warnings
    const warningMatch = line.match(/^(.+):(\d+):(\d+):\s*warning:\s*(.+)$/);
    if (warningMatch) {
      warnings.push({
        line: parseInt(warningMatch[2], 10),
        column: parseInt(warningMatch[3], 10),
        message: warningMatch[4],
      });
      continue;
    }
  }
  
  return {
    success: success && errors.length === 0,
    errors,
    warnings,
    compileTime,
  };
}
```

**/Users/erichowens/coding/metal-shader-mcp/src/profiler.ts**
```
/**
 * Performance Profiler for Metal Shaders
 * Measures GPU and CPU performance metrics
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

const execAsync = promisify(exec);

export interface PerformanceMetrics {
  averageFrameTime: number;  // milliseconds
  fps: number;
  gpuTime: number;           // milliseconds
  cpuTime: number;           // milliseconds
  memoryUsage: number;       // bytes
  powerUsage: 'low' | 'medium' | 'high';
  threadCount: number;
  drawCalls: number;
  verticesProcessed: number;
  fragmentsProcessed: number;
}

export interface ProfileOptions {
  shaderPath: string;
  iterations: number;
  resolution: {
    width: number;
    height: number;
  };
  warmupIterations?: number;
}

export class PerformanceProfiler {
  private metricsHistory: Map<string, PerformanceMetrics[]> = new Map();
  
  /**
   * Profile shader performance
   */
  async profileShader(options: ProfileOptions): Promise<PerformanceMetrics> {
    const { 
      shaderPath, 
      iterations, 
      resolution, 
      warmupIterations = 10 
    } = options;
    
    // Create profiling program
    const profileProgram = this.generateProfileProgram(options);
    const tempDir = path.join(os.tmpdir(), 'metal-shader-profiler');
    await fs.mkdir(tempDir, { recursive: true });
    
    const programPath = path.join(tempDir, 'profiler.swift');
    const executablePath = path.join(tempDir, 'profiler');
    
    try {
      // Write and compile profiling program
      await fs.writeFile(programPath, profileProgram);
      
      const compileCmd = `swiftc -O -o ${executablePath} ${programPath}`;
      await execAsync(compileCmd);
      
      // Run profiler
      const runCmd = `${executablePath} ${shaderPath} ${iterations} ${resolution.width} ${resolution.height} ${warmupIterations}`;
      const { stdout } = await execAsync(runCmd);
      
      // Parse metrics
      const metrics = this.parseMetrics(stdout);
      
      // Store in history
      if (!this.metricsHistory.has(shaderPath)) {
        this.metricsHistory.set(shaderPath, []);
      }
      this.metricsHistory.get(shaderPath)!.push(metrics);
      
      // Cleanup
      await fs.rm(tempDir, { recursive: true, force: true });
      
      return metrics;
      
    } catch (error) {
      await fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});
      throw error;
    }
  }
  
  /**
   * Run comparative benchmark between shaders
   */
  async compareShaders(
    shaderPaths: string[],
    options: Omit<ProfileOptions, 'shaderPath'>
  ): Promise<Map<string, PerformanceMetrics>> {
    const results = new Map<string, PerformanceMetrics>();
    
    for (const shaderPath of shaderPaths) {
      const metrics = await this.profileShader({
        ...options,
        shaderPath,
      });
      results.set(shaderPath, metrics);
    }
    
    return results;
  }
  
  /**
   * Get performance history for a shader
   */
  getHistory(shaderPath: string): PerformanceMetrics[] {
    return this.metricsHistory.get(shaderPath) || [];
  }
  
  /**
   * Generate performance report
   */
  generateReport(metrics: PerformanceMetrics): string {
    const report = [
      '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê',
      '       PERFORMANCE PROFILING REPORT     ',
      '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê',
      '',
      'üìä Frame Performance',
      `   Average Frame Time: ${metrics.averageFrameTime.toFixed(2)}ms`,
      `   Frames Per Second: ${metrics.fps.toFixed(1)} FPS`,
      `   ${this.getFPSRating(metrics.fps)}`,
      '',
      '‚è±Ô∏è  Processing Time',
      `   GPU Time: ${metrics.gpuTime.toFixed(2)}ms`,
      `   CPU Time: ${metrics.cpuTime.toFixed(2)}ms`,
      `   GPU/CPU Ratio: ${(metrics.gpuTime / metrics.cpuTime).toFixed(2)}x`,
      '',
      'üíæ Resource Usage',
      `   Memory: ${(metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB`,
      `   Power Usage: ${metrics.powerUsage}`,
      `   Thread Count: ${metrics.threadCount}`,
      '',
      'üé® Rendering Stats',
      `   Draw Calls: ${metrics.drawCalls}`,
      `   Vertices: ${this.formatNumber(metrics.verticesProcessed)}`,
      `   Fragments: ${this.formatNumber(metrics.fragmentsProcessed)}`,
      '',
      '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê',
    ];
    
    return report.join('\n');
  }
  
  /**
   * Generate Swift profiling program
   */
  private generateProfileProgram(options: ProfileOptions): string {
    return `
import Metal
import MetalKit
import QuartzCore
import Foundation

// Command line arguments
let args = CommandLine.arguments
guard args.count >= 6 else {
    print("Usage: profiler <shader.metallib> <iterations> <width> <height> <warmup>")
    exit(1)
}

let shaderPath = args[1]
let iterations = Int(args[2]) ?? 100
let width = Int(args[3]) ?? 512
let height = Int(args[4]) ?? 512
let warmupIterations = Int(args[5]) ?? 10

// Setup Metal
guard let device = MTLCreateSystemDefaultDevice() else {
    print("Metal is not supported")
    exit(1)
}

let commandQueue = device.makeCommandQueue()!

// Load shader library
let library = try! device.makeLibrary(filepath: shaderPath)

// Create render pipeline
let pipelineDescriptor = MTLRenderPipelineDescriptor()
pipelineDescriptor.vertexFunction = library.makeFunction(name: "vertexShader")
pipelineDescriptor.fragmentFunction = library.makeFunction(name: "fragmentShader")
pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm

let pipelineState = try! device.makeRenderPipelineState(descriptor: pipelineDescriptor)

// Create texture
let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(
    pixelFormat: .bgra8Unorm,
    width: width,
    height: height,
    mipmapped: false
)
textureDescriptor.usage = [.renderTarget, .shaderRead]
textureDescriptor.storageMode = .private
let texture = device.makeTexture(descriptor: textureDescriptor)!

// Setup render pass
let renderPassDescriptor = MTLRenderPassDescriptor()
renderPassDescriptor.colorAttachments[0].texture = texture
renderPassDescriptor.colorAttachments[0].loadAction = .clear
renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 1)
renderPassDescriptor.colorAttachments[0].storeAction = .store

// Uniforms
struct Uniforms {
    var time: Float = 0.0
    var resolution: SIMD2<Float> = SIMD2<Float>(Float(width), Float(height))
    var touchPoint: SIMD2<Float> = SIMD2<Float>(0.5, 0.5)
}

// Warmup
for _ in 0..<warmupIterations {
    var uniformData = Uniforms(time: Float.random(in: 0...1))
    let uniformBuffer = device.makeBuffer(bytes: &uniformData, length: MemoryLayout<Uniforms>.size, options: [])
    
    let commandBuffer = commandQueue.makeCommandBuffer()!
    let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!
    
    renderEncoder.setRenderPipelineState(pipelineState)
    renderEncoder.setFragmentBuffer(uniformBuffer, offset: 0, index: 0)
    renderEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
    renderEncoder.endEncoding()
    
    commandBuffer.commit()
    commandBuffer.waitUntilCompleted()
}

// Profiling
var frameTimes: [TimeInterval] = []
var gpuTimes: [TimeInterval] = []
var cpuTimes: [TimeInterval] = []
let startMemory = getMemoryUsage()

for i in 0..<iterations {
    let frameStart = CACurrentMediaTime()
    let cpuStart = CACurrentMediaTime()
    
    var uniformData = Uniforms(time: Float(i) / Float(iterations))
    let uniformBuffer = device.makeBuffer(bytes: &uniformData, length: MemoryLayout<Uniforms>.size, options: [])
    
    let commandBuffer = commandQueue.makeCommandBuffer()!
    
    let cpuEnd = CACurrentMediaTime()
    cpuTimes.append((cpuEnd - cpuStart) * 1000)
    
    // GPU timing
    let gpuStart = CACurrentMediaTime()
    
    let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!
    renderEncoder.setRenderPipelineState(pipelineState)
    renderEncoder.setFragmentBuffer(uniformBuffer, offset: 0, index: 0)
    renderEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
    renderEncoder.endEncoding()
    
    commandBuffer.commit()
    commandBuffer.waitUntilCompleted()
    
    let gpuEnd = CACurrentMediaTime()
    gpuTimes.append((gpuEnd - gpuStart) * 1000)
    
    let frameEnd = CACurrentMediaTime()
    frameTimes.append((frameEnd - frameStart) * 1000)
}

let endMemory = getMemoryUsage()

// Calculate metrics
let averageFrameTime = frameTimes.reduce(0, +) / Double(frameTimes.count)
let averageGPUTime = gpuTimes.reduce(0, +) / Double(gpuTimes.count)
let averageCPUTime = cpuTimes.reduce(0, +) / Double(cpuTimes.count)
let fps = 1000.0 / averageFrameTime
let memoryUsage = endMemory - startMemory

// Determine power usage based on frame time
let powerUsage: String
if averageFrameTime < 8.33 { // 120fps
    powerUsage = "high"
} else if averageFrameTime < 16.67 { // 60fps
    powerUsage = "medium"
} else {
    powerUsage = "low"
}

// Output metrics as JSON
let metrics: [String: Any] = [
    "averageFrameTime": averageFrameTime,
    "fps": fps,
    "gpuTime": averageGPUTime,
    "cpuTime": averageCPUTime,
    "memoryUsage": memoryUsage,
    "powerUsage": powerUsage,
    "threadCount": Thread.activeCount,
    "drawCalls": iterations,
    "verticesProcessed": 4 * iterations,
    "fragmentsProcessed": width * height * iterations
]

let jsonData = try! JSONSerialization.data(withJSONObject: metrics)
print(String(data: jsonData, encoding: .utf8)!)

// Helper function to get memory usage
func getMemoryUsage() -> Int64 {
    var info = mach_task_basic_info()
    var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size) / 4
    
    let result = withUnsafeMutablePointer(to: &info) {
        $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
            task_info(mach_task_self_,
                     task_flavor_t(MACH_TASK_BASIC_INFO),
                     $0,
                     &count)
        }
    }
    
    return result == KERN_SUCCESS ? Int64(info.resident_size) : 0
}

// Extension for thread count
extension Thread {
    static var activeCount: Int {
        return Thread.isMultiThreaded() ? ProcessInfo.processInfo.activeProcessorCount : 1
    }
}
`;
  }
  
  /**
   * Parse metrics from profiler output
   */
  private parseMetrics(output: string): PerformanceMetrics {
    try {
      const metrics = JSON.parse(output);
      return {
        averageFrameTime: metrics.averageFrameTime,
        fps: metrics.fps,
        gpuTime: metrics.gpuTime,
        cpuTime: metrics.cpuTime,
        memoryUsage: metrics.memoryUsage,
        powerUsage: metrics.powerUsage,
        threadCount: metrics.threadCount,
        drawCalls: metrics.drawCalls,
        verticesProcessed: metrics.verticesProcessed,
        fragmentsProcessed: metrics.fragmentsProcessed,
      };
    } catch (error) {
      throw new Error(`Failed to parse metrics: ${error}`);
    }
  }
  
  /**
   * Get FPS rating emoji
   */
  private getFPSRating(fps: number): string {
    if (fps >= 120) return 'üöÄ Blazing Fast (120+ FPS)';
    if (fps >= 60) return '‚úÖ Smooth (60+ FPS)';
    if (fps >= 30) return '‚ö†Ô∏è Acceptable (30+ FPS)';
    return '‚ùå Poor Performance (<30 FPS)';
  }
  
  /**
   * Format large numbers
   */
  private formatNumber(num: number): string {
    if (num >= 1e9) return `${(num / 1e9).toFixed(1)}B`;
    if (num >= 1e6) return `${(num / 1e6).toFixed(1)}M`;
    if (num >= 1e3) return `${(num / 1e3).toFixed(1)}K`;
    return num.toString();
  }
}
```

**/Users/erichowens/coding/metal-shader-mcp/src/parameters.ts**
```
/**
 * Shader Parameters Management
 * Manages uniform parameters and shader configurations
 */

export interface UniformValue {
  value: number | number[] | boolean;
  type: 'float' | 'vec2' | 'vec3' | 'vec4' | 'mat4' | 'bool' | 'int';
  min?: number;
  max?: number;
  step?: number;
  description?: string;
}

export interface ShaderConfig {
  name: string;
  uniforms: Record<string, UniformValue>;
  metadata?: {
    author?: string;
    version?: string;
    description?: string;
    tags?: string[];
  };
}

export class ShaderParameters {
  private configs: Map<string, ShaderConfig> = new Map();
  private currentUniforms: Record<string, any> = {};
  
  /**
   * Register a shader configuration
   */
  registerConfig(config: ShaderConfig): void {
    this.configs.set(config.name, config);
  }
  
  /**
   * Load configuration by name
   */
  loadConfig(name: string): ShaderConfig | undefined {
    const config = this.configs.get(name);
    if (config) {
      // Set current uniforms from config
      this.currentUniforms = {};
      for (const [key, uniform] of Object.entries(config.uniforms)) {
        this.currentUniforms[key] = uniform.value;
      }
    }
    return config;
  }
  
  /**
   * Update uniform values
   */
  updateUniforms(updates: Record<string, any>): void {
    Object.assign(this.currentUniforms, updates);
  }
  
  /**
   * Get current uniform values
   */
  getUniforms(): Record<string, any> {
    return { ...this.currentUniforms };
  }
  
  /**
   * Generate Metal buffer data for uniforms
   */
  generateBufferData(): ArrayBuffer {
    // Calculate total size needed
    let totalSize = 0;
    const layout: Array<{ key: string; offset: number; size: number }> = [];
    
    for (const [key, value] of Object.entries(this.currentUniforms)) {
      const size = this.getUniformSize(value);
      layout.push({ key, offset: totalSize, size });
      totalSize += size;
    }
    
    // Align to 16 bytes
    totalSize = Math.ceil(totalSize / 16) * 16;
    
    // Create buffer
    const buffer = new ArrayBuffer(totalSize);
    const view = new DataView(buffer);
    
    // Write values
    for (const { key, offset } of layout) {
      const value = this.currentUniforms[key];
      this.writeValue(view, offset, value);
    }
    
    return buffer;
  }
  
  /**
   * Create preset configurations
   */
  static createPresets(): ShaderParameters {
    const params = new ShaderParameters();
    
    // Kaleidoscope preset
    params.registerConfig({
      name: 'kaleidoscope',
      uniforms: {
        time: {
          value: 0,
          type: 'float',
          min: 0,
          max: 1,
          description: 'Animation time',
        },
        segments: {
          value: 6,
          type: 'int',
          min: 3,
          max: 12,
          description: 'Number of kaleidoscope segments',
        },
        rotation: {
          value: 0,
          type: 'float',
          min: 0,
          max: Math.PI * 2,
          description: 'Rotation angle',
        },
        zoom: {
          value: 1,
          type: 'float',
          min: 0.5,
          max: 3,
          description: 'Zoom level',
        },
        center: {
          value: [0.5, 0.5],
          type: 'vec2',
          description: 'Center point',
        },
        colorShift: {
          value: [1, 1, 1],
          type: 'vec3',
          description: 'RGB color multipliers',
        },
      },
      metadata: {
        author: 'Shimmer Team',
        version: '1.0.0',
        description: 'Classic kaleidoscope effect with rotation and zoom',
        tags: ['kaleidoscope', 'mirror', 'symmetric'],
      },
    });
    
    // Prismatic dissolve preset
    params.registerConfig({
      name: 'prismatic_dissolve',
      uniforms: {
        progress: {
          value: 0,
          type: 'float',
          min: 0,
          max: 1,
          description: 'Dissolve progress',
        },
        blockSize: {
          value: 32,
          type: 'float',
          min: 8,
          max: 128,
          description: 'Size of color blocks',
        },
        noiseScale: {
          value: 2,
          type: 'float',
          min: 0.5,
          max: 10,
          description: 'Noise pattern scale',
        },
        chromaticAberration: {
          value: 0.01,
          type: 'float',
          min: 0,
          max: 0.1,
          description: 'Chromatic aberration amount',
        },
        breathingRate: {
          value: 0.4,
          type: 'float',
          min: 0.1,
          max: 2,
          description: 'Breathing animation rate (Hz)',
        },
      },
      metadata: {
        author: 'Shimmer Team',
        version: '1.0.0',
        description: 'Prismatic RGBY block dissolve effect',
        tags: ['dissolve', 'prismatic', 'transition'],
      },
    });
    
    // Liquid geometry preset
    params.registerConfig({
      name: 'liquid_geometry',
      uniforms: {
        time: {
          value: 0,
          type: 'float',
          description: 'Animation time',
        },
        viscosity: {
          value: 0.95,
          type: 'float',
          min: 0.8,
          max: 0.99,
          description: 'Liquid viscosity',
        },
        turbulence: {
          value: 0.5,
          type: 'float',
          min: 0,
          max: 1,
          description: 'Turbulence amount',
        },
        flowDirection: {
          value: [1, 0],
          type: 'vec2',
          description: 'Flow direction vector',
        },
        colorBleed: {
          value: 0.2,
          type: 'float',
          min: 0,
          max: 1,
          description: 'Color bleeding between regions',
        },
      },
      metadata: {
        author: 'Shimmer Team',
        version: '1.0.0',
        description: 'Liquid flow geometry effect',
        tags: ['liquid', 'flow', 'organic'],
      },
    });
    
    // Mondrian grid preset
    params.registerConfig({
      name: 'mondrian_grid',
      uniforms: {
        gridDensity: {
          value: 8,
          type: 'int',
          min: 2,
          max: 20,
          description: 'Grid subdivision density',
        },
        lineThickness: {
          value: 2,
          type: 'float',
          min: 0.5,
          max: 10,
          description: 'Grid line thickness',
        },
        primaryColors: {
          value: [1, 0, 0, 1],  // RGBA
          type: 'vec4',
          description: 'Primary color palette',
        },
        randomSeed: {
          value: 42,
          type: 'int',
          description: 'Random seed for grid generation',
        },
        animationPhase: {
          value: 0,
          type: 'float',
          min: 0,
          max: 1,
          description: 'Animation phase',
        },
      },
      metadata: {
        author: 'Shimmer Team',
        version: '1.0.0',
        description: 'Mondrian-style grid layout',
        tags: ['grid', 'mondrian', 'geometric'],
      },
    });
    
    return params;
  }
  
  /**
   * Export configuration to JSON
   */
  exportConfig(name: string): string | undefined {
    const config = this.configs.get(name);
    if (config) {
      return JSON.stringify(config, null, 2);
    }
    return undefined;
  }
  
  /**
   * Import configuration from JSON
   */
  importConfig(json: string): void {
    try {
      const config = JSON.parse(json) as ShaderConfig;
      this.registerConfig(config);
    } catch (error) {
      throw new Error(`Failed to import config: ${error}`);
    }
  }
  
  /**
   * Get size of uniform value in bytes
   */
  private getUniformSize(value: any): number {
    if (typeof value === 'number') return 4;
    if (typeof value === 'boolean') return 4;
    if (Array.isArray(value)) {
      return value.length * 4;
    }
    return 4;
  }
  
  /**
   * Write value to buffer
   */
  private writeValue(view: DataView, offset: number, value: any): void {
    if (typeof value === 'number') {
      view.setFloat32(offset, value, true);
    } else if (typeof value === 'boolean') {
      view.setInt32(offset, value ? 1 : 0, true);
    } else if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        view.setFloat32(offset + i * 4, value[i], true);
      }
    }
  }
  
  /**
   * Validate uniform value against its type
   */
  validateUniform(key: string, value: any): boolean {
    // Find the uniform definition
    for (const config of this.configs.values()) {
      const uniform = config.uniforms[key];
      if (uniform) {
        switch (uniform.type) {
          case 'float':
          case 'int':
            return typeof value === 'number';
          case 'bool':
            return typeof value === 'boolean';
          case 'vec2':
            return Array.isArray(value) && value.length === 2;
          case 'vec3':
            return Array.isArray(value) && value.length === 3;
          case 'vec4':
            return Array.isArray(value) && value.length === 4;
          case 'mat4':
            return Array.isArray(value) && value.length === 16;
          default:
            return false;
        }
      }
    }
    
    // If no definition found, accept any value
    return true;
  }
}
```

**/Users/erichowens/coding/metal-shader-mcp/src/hotReload.ts**
```
/**
 * Hot Reload Manager for Metal Shaders
 * Watches shader files and triggers recompilation on changes
 */

import { watch, FSWatcher } from 'chokidar';
import { EventEmitter } from 'events';
import * as path from 'path';
import * as fs from 'fs/promises';
import { compileShader, CompilationResult } from './compiler.js';

export interface WatchOptions {
  debounce?: number;
  autoCompile?: boolean;
  optimize?: boolean;
}

export interface FileChange {
  path: string;
  type: 'add' | 'change' | 'unlink';
  timestamp: Date;
}

export class HotReloadManager extends EventEmitter {
  private watchers: Map<string, FSWatcher> = new Map();
  private compilationCache: Map<string, CompilationResult> = new Map();
  private changeQueue: Map<string, NodeJS.Timeout> = new Map();
  
  /**
   * Watch a shader file or directory
   */
  async watch(
    filePath: string,
    onChange: (change: FileChange) => void,
    options: WatchOptions = {}
  ): Promise<void> {
    const { debounce = 300, autoCompile = true, optimize = false } = options;
    
    // Check if already watching
    if (this.watchers.has(filePath)) {
      console.warn(`Already watching ${filePath}`);
      return;
    }
    
    // Create watcher
    const watcher = watch(filePath, {
      persistent: true,
      ignored: /(^|[\/\\])\../, // ignore dotfiles
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 200,
        pollInterval: 100,
      },
    });
    
    // Handle file changes
    watcher.on('change', async (changedPath) => {
      this.handleChange(changedPath, 'change', debounce, async () => {
        const change: FileChange = {
          path: changedPath,
          type: 'change',
          timestamp: new Date(),
        };
        
        // Auto-compile if enabled
        if (autoCompile && changedPath.endsWith('.metal')) {
          try {
            const code = await fs.readFile(changedPath, 'utf-8');
            const result = await compileShader(code, {
              target: 'air',
              optimize,
            });
            
            this.compilationCache.set(changedPath, result);
            this.emit('compiled', { path: changedPath, result });
            
            // Notify about compilation result
            if (result.success) {
              this.emit('success', {
                path: changedPath,
                outputPath: result.outputPath,
                compileTime: result.compileTime,
              });
            } else {
              this.emit('error', {
                path: changedPath,
                errors: result.errors,
                warnings: result.warnings,
              });
            }
          } catch (error) {
            this.emit('error', {
              path: changedPath,
              error: error,
            });
          }
        }
        
        // Call user callback
        onChange(change);
      });
    });
    
    watcher.on('add', (addedPath) => {
      this.handleChange(addedPath, 'add', debounce, () => {
        onChange({
          path: addedPath,
          type: 'add',
          timestamp: new Date(),
        });
      });
    });
    
    watcher.on('unlink', (removedPath) => {
      this.handleChange(removedPath, 'unlink', debounce, () => {
        // Clear compilation cache
        this.compilationCache.delete(removedPath);
        
        onChange({
          path: removedPath,
          type: 'unlink',
          timestamp: new Date(),
        });
      });
    });
    
    watcher.on('error', (error) => {
      this.emit('error', { path: filePath, error });
    });
    
    // Store watcher
    this.watchers.set(filePath, watcher);
    
    this.emit('watching', { path: filePath });
  }
  
  /**
   * Stop watching a file or directory
   */
  async unwatch(filePath: string): Promise<void> {
    const watcher = this.watchers.get(filePath);
    if (watcher) {
      await watcher.close();
      this.watchers.delete(filePath);
      this.compilationCache.delete(filePath);
      this.emit('unwatched', { path: filePath });
    }
  }
  
  /**
   * Stop watching all files
   */
  async unwatchAll(): Promise<void> {
    const promises = Array.from(this.watchers.keys()).map(path => this.unwatch(path));
    await Promise.all(promises);
  }
  
  /**
   * Get compilation result from cache
   */
  getCompilationResult(filePath: string): CompilationResult | undefined {
    return this.compilationCache.get(filePath);
  }
  
  /**
   * Get all watched paths
   */
  getWatchedPaths(): string[] {
    return Array.from(this.watchers.keys());
  }
  
  /**
   * Handle file changes with debouncing
   */
  private handleChange(
    filePath: string,
    type: string,
    debounce: number,
    callback: () => void
  ): void {
    // Clear existing timeout
    const existingTimeout = this.changeQueue.get(filePath);
    if (existingTimeout) {
      clearTimeout(existingTimeout);
    }
    
    // Set new timeout
    const timeout = setTimeout(() => {
      this.changeQueue.delete(filePath);
      callback();
    }, debounce);
    
    this.changeQueue.set(filePath, timeout);
  }
  
  /**
   * Create a development server with hot reload
   */
  async createDevServer(port: number = 3000): Promise<void> {
    const express = await import('express');
    const { WebSocketServer } = await import('ws');
    
    const app = express.default();
    const server = app.listen(port);
    const wss = new WebSocketServer({ server });
    
    // Track connected clients
    const clients = new Set<any>();
    
    // Serve static files
    app.use(express.static(process.cwd()));
    
    // WebSocket connections
    wss.on('connection', (ws) => {
      clients.add(ws);
      
      ws.on('close', () => {
        clients.delete(ws);
      });
      
      // Send initial state
      ws.send(JSON.stringify({
        type: 'connected',
        watched: this.getWatchedPaths(),
      }));
    });
    
    // Listen for compilation events
    this.on('compiled', ({ path, result }) => {
      const message = JSON.stringify({
        type: 'compiled',
        path,
        success: result.success,
        errors: result.errors,
        warnings: result.warnings,
      });
      
      clients.forEach(client => {
        if (client.readyState === 1) { // WebSocket.OPEN
          client.send(message);
        }
      });
    });
    
    // Serve development dashboard
    app.get('/dashboard', (req, res) => {
      res.send(this.getDashboardHTML(port));
    });
    
    console.log(`Hot reload server running at http://localhost:${port}/dashboard`);
  }
  
  /**
   * Get HTML for development dashboard
   */
  private getDashboardHTML(port: number): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>Metal Shader Hot Reload</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .status {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .files {
            display: grid;
            gap: 15px;
        }
        
        .file {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .file.success {
            border-left-color: #4CAF50;
        }
        
        .file.error {
            border-left-color: #f44336;
        }
        
        .file.compiling {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .file-path {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin-bottom: 10px;
            color: #64B5F6;
        }
        
        .file-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }
        
        .errors {
            margin-top: 10px;
            padding: 10px;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .error-line {
            margin: 5px 0;
            color: #ff5252;
        }
        
        .warnings {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 193, 7, 0.1);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .warning-line {
            margin: 5px 0;
            color: #FFC107;
        }
        
        .compile-time {
            color: #4CAF50;
            font-weight: 600;
        }
        
        .log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            max-height: 300px;
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .log-entry {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #888;
        }
        
        .log-entry.info { color: #64B5F6; }
        .log-entry.success { color: #4CAF50; }
        .log-entry.error { color: #f44336; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî• Metal Shader Hot Reload</h1>
        <div class="status" id="status">Connecting...</div>
    </div>
    
    <div class="files" id="files"></div>
    
    <div class="log" id="log"></div>
    
    <script>
        const ws = new WebSocket('ws://localhost:${port}');
        const status = document.getElementById('status');
        const filesContainer = document.getElementById('files');
        const log = document.getElementById('log');
        
        const files = new Map();
        
        ws.onopen = () => {
            status.textContent = 'üü¢ Connected';
            addLog('Connected to hot reload server', 'success');
        };
        
        ws.onclose = () => {
            status.textContent = 'üî¥ Disconnected';
            addLog('Disconnected from server', 'error');
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            switch(data.type) {
                case 'connected':
                    data.watched.forEach(path => {
                        addFile(path);
                    });
                    break;
                    
                case 'compiled':
                    updateFile(data.path, data);
                    break;
            }
        };
        
        function addFile(path) {
            if (!files.has(path)) {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file';
                fileDiv.innerHTML = \`
                    <div class="file-path">\${path}</div>
                    <div class="file-status">
                        <span>Watching...</span>
                    </div>
                \`;
                filesContainer.appendChild(fileDiv);
                files.set(path, fileDiv);
                addLog(\`Watching \${path}\`, 'info');
            }
        }
        
        function updateFile(path, data) {
            const fileDiv = files.get(path);
            if (!fileDiv) {
                addFile(path);
                return;
            }
            
            fileDiv.className = 'file ' + (data.success ? 'success' : 'error');
            
            let statusHTML = \`<div class="file-status">\`;
            
            if (data.success) {
                statusHTML += \`<span>‚úÖ Compiled successfully</span>\`;
                addLog(\`‚úÖ \${path} compiled successfully\`, 'success');
            } else {
                statusHTML += \`<span>‚ùå Compilation failed</span>\`;
                addLog(\`‚ùå \${path} compilation failed\`, 'error');
            }
            
            statusHTML += \`</div>\`;
            
            if (data.errors && data.errors.length > 0) {
                statusHTML += \`<div class="errors">\`;
                data.errors.forEach(err => {
                    statusHTML += \`<div class="error-line">Line \${err.line}:\${err.column} - \${err.message}</div>\`;
                });
                statusHTML += \`</div>\`;
            }
            
            if (data.warnings && data.warnings.length > 0) {
                statusHTML += \`<div class="warnings">\`;
                data.warnings.forEach(warn => {
                    statusHTML += \`<div class="warning-line">Line \${warn.line}:\${warn.column} - \${warn.message}</div>\`;
                });
                statusHTML += \`</div>\`;
            }
            
            fileDiv.innerHTML = \`
                <div class="file-path">\${path}</div>
                \${statusHTML}
            \`;
        }
        
        function addLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }
    </script>
</body>
</html>
`;
  }
}
```

**/Users/erichowens/coding/metal-shader-mcp/src/hot-reload.ts**
```
/**
 * Metal Shader Hot Reload Tool
 * MCP Tool #1: Live shader reloading without restart
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { CallToolRequestSchema, ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { promises as fs } from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as path from 'path';
import * as crypto from 'crypto';

const execAsync = promisify(exec);

interface ShaderState {
  source: string;
  hash: string;
  lastCompiled: Date;
  parameters: Map<string, any>;
  errors: string[];
}

interface WatchedShader {
  path: string;
  state: ShaderState;
  watcher?: fs.FileHandle;
}

export class HotReloadTool {
  private watchers = new Map<string, WatchedShader>();
  private compiledCache = new Map<string, string>();
  private server: Server;

  constructor() {
    this.server = new Server({
      name: "metal-hot-reload",
      version: "1.0.0",
    }, {
      capabilities: {
        tools: {}
      }
    });

    this.setupHandlers();
  }

  private setupHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: "shader_watch",
          description: "Watch a Metal shader file for changes and auto-recompile",
          inputSchema: {
            type: "object",
            properties: {
              path: { type: "string", description: "Path to Metal shader file" },
              preserveState: { type: "boolean", description: "Preserve parameters on reload" }
            },
            required: ["path"]
          }
        },
        {
          name: "shader_reload",
          description: "Manually reload and recompile a shader",
          inputSchema: {
            type: "object",
            properties: {
              path: { type: "string", description: "Path to Metal shader file" },
              source: { type: "string", description: "Optional new source code" }
            },
            required: ["path"]
          }
        },
        {
          name: "shader_compile",
          description: "Compile Metal shader and return compiled binary",
          inputSchema: {
            type: "object",
            properties: {
              source: { type: "string", description: "Metal shader source code" },
              target: { type: "string", enum: ["air", "metallib"], description: "Compilation target" }
            },
            required: ["source"]
          }
        },
        {
          name: "shader_validate",
          description: "Validate shader syntax without full compilation",
          inputSchema: {
            type: "object",
            properties: {
              source: { type: "string", description: "Metal shader source code" }
            },
            required: ["source"]
          }
        },
        {
          name: "shader_state",
          description: "Get current state of a watched shader",
          inputSchema: {
            type: "object",
            properties: {
              path: { type: "string", description: "Path to Metal shader file" }
            },
            required: ["path"]
          }
        },
        {
          name: "shader_stop_watch",
          description: "Stop watching a shader file",
          inputSchema: {
            type: "object",
            properties: {
              path: { type: "string", description: "Path to Metal shader file" }
            },
            required: ["path"]
          }
        },
        {
          name: "shader_list_watched",
          description: "List all currently watched shader files",
          inputSchema: {
            type: "object",
            properties: {}
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case "shader_watch":
          return await this.watchShader((args as any).path as string, (args as any).preserveState as boolean);
        
        case "shader_reload":
          return await this.reloadShader((args as any).path as string, (args as any).source as string);
        
        case "shader_compile":
          return await this.compileShader((args as any).source as string, (args as any).target as string);
        
        case "shader_validate":
          return await this.validateShader((args as any).source as string);
        
        case "shader_state":
          return await this.getShaderState((args as any).path as string);
        
        case "shader_stop_watch":
          return await this.stopWatching((args as any).path as string);
        
        case "shader_list_watched":
          return await this.listWatched();
        
        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  private async watchShader(shaderPath: string, preserveState: boolean = true) {
    try {
      const absolutePath = path.resolve(shaderPath);
      const source = await fs.readFile(absolutePath, 'utf-8');
      const hash = crypto.createHash('md5').update(source).digest('hex');

      const watcher: WatchedShader = {
        path: absolutePath,
        state: {
          source,
          hash,
          lastCompiled: new Date(),
          parameters: new Map(),
          errors: []
        }
      };

      // Set up file watcher
      const watchInterval = setInterval(async () => {
        try {
          const newSource = await fs.readFile(absolutePath, 'utf-8');
          const newHash = crypto.createHash('md5').update(newSource).digest('hex');
          
          if (newHash !== watcher.state.hash) {
            console.log(`Shader changed: ${shaderPath}`);
            
            // Compile new version
            const result = await this.compileShader(newSource, 'air');
            
            if (result.success) {
              const oldParams = preserveState ? watcher.state.parameters : new Map();
              watcher.state = {
                source: newSource,
                hash: newHash,
                lastCompiled: new Date(),
                parameters: oldParams,
                errors: []
              };
              
              // Emit reload event
              console.log(`Shader reloaded successfully: ${shaderPath}`);
            } else {
              watcher.state.errors = [result.error || 'Compilation failed'];
              console.error(`Shader compilation failed: ${result.error}`);
            }
          }
        } catch (error) {
          console.error(`Watch error: ${error}`);
        }
      }, 500); // Check every 500ms

      this.watchers.set(absolutePath, watcher);

      return {
        content: [{
          type: "text",
          text: `Watching shader: ${shaderPath}\nInitial hash: ${hash}\nPreserving state: ${preserveState}`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `Error watching shader: ${error}`
        }],
        isError: true
      };
    }
  }

  private async reloadShader(shaderPath: string, newSource?: string) {
    try {
      const absolutePath = path.resolve(shaderPath);
      const source = newSource || await fs.readFile(absolutePath, 'utf-8');
      
      // Compile
      const result = await this.compileShader(source, 'air');
      
      if (result.success) {
        // Update watched state if exists
        const watcher = this.watchers.get(absolutePath);
        if (watcher) {
          watcher.state.source = source;
          watcher.state.hash = crypto.createHash('md5').update(source).digest('hex');
          watcher.state.lastCompiled = new Date();
          watcher.state.errors = [];
        }
        
        return {
          content: [{
            type: "text",
            text: `Shader reloaded successfully\nCompilation time: ${result.compilationTime}ms`
          }]
        };
      } else {
        return {
          content: [{
            type: "text",
            text: `Reload failed: ${result.error}`
          }],
          isError: true
        };
      }
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `Error reloading shader: ${error}`
        }],
        isError: true
      };
    }
  }

  private async compileShader(source: string, target: string = 'air') {
    const startTime = Date.now();
    
    try {
      // Write to temp file
      const tempPath = `/tmp/shader_${Date.now()}.metal`;
      await fs.writeFile(tempPath, source);
      
      // Compile based on target
      let command = '';
      let outputPath = '';
      
      if (target === 'metallib') {
        outputPath = tempPath.replace('.metal', '.metallib');
        command = `xcrun -sdk macosx metal -c ${tempPath} -o ${tempPath}.air && xcrun -sdk macosx metallib ${tempPath}.air -o ${outputPath}`;
      } else {
        outputPath = tempPath.replace('.metal', '.air');
        command = `xcrun -sdk macosx metal -c ${tempPath} -o ${outputPath}`;
      }
      
      const { stdout, stderr } = await execAsync(command);
      
      if (stderr && !stderr.includes('warning')) {
        throw new Error(stderr);
      }
      
      // Read compiled output
      const compiled = await fs.readFile(outputPath);
      const compilationTime = Date.now() - startTime;
      
      // Cache result
      const hash = crypto.createHash('md5').update(source).digest('hex');
      this.compiledCache.set(hash, outputPath);
      
      // Clean up temp files
      await fs.unlink(tempPath).catch(() => {});
      
      return {
        success: true,
        compiledPath: outputPath,
        compilationTime,
        content: [{
          type: "text",
          text: `Compilation successful (${compilationTime}ms)\nOutput: ${outputPath}`
        }]
      };
    } catch (error) {
      return {
        success: false,
        error: (error as Error).toString(),
        compilationTime: Date.now() - startTime,
        content: [{
          type: "text",
          text: `Compilation failed: ${error}`
        }],
        isError: true
      };
    }
  }

  private async validateShader(source: string) {
    try {
      // Quick syntax validation using Metal compiler
      const tempPath = `/tmp/validate_${Date.now()}.metal`;
      await fs.writeFile(tempPath, source);
      
      const { stdout, stderr } = await execAsync(
        `xcrun -sdk macosx metal -fsyntax-only ${tempPath}`
      );
      
      await fs.unlink(tempPath).catch(() => {});
      
      if (stderr && !stderr.includes('warning')) {
        return {
          content: [{
            type: "text",
            text: `Validation failed:\n${stderr}`
          }],
          isError: true
        };
      }
      
      return {
        content: [{
          type: "text",
          text: "Shader validation passed"
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `Validation error: ${error}`
        }],
        isError: true
      };
    }
  }

  private async getShaderState(shaderPath: string) {
    const absolutePath = path.resolve(shaderPath);
    const watcher = this.watchers.get(absolutePath);
    
    if (!watcher) {
      return {
        content: [{
          type: "text",
          text: `No watcher found for: ${shaderPath}`
        }],
        isError: true
      };
    }
    
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          path: watcher.path,
          hash: watcher.state.hash,
          lastCompiled: watcher.state.lastCompiled,
          hasErrors: watcher.state.errors.length > 0,
          errors: watcher.state.errors,
          parameters: Array.from(watcher.state.parameters.entries())
        }, null, 2)
      }]
    };
  }

  private async stopWatching(shaderPath: string) {
    const absolutePath = path.resolve(shaderPath);
    const watcher = this.watchers.get(absolutePath);
    
    if (watcher) {
      this.watchers.delete(absolutePath);
      return {
        content: [{
          type: "text",
          text: `Stopped watching: ${shaderPath}`
        }]
      };
    }
    
    return {
      content: [{
        type: "text",
        text: `No watcher found for: ${shaderPath}`
      }],
      isError: true
    };
  }

  private async listWatched() {
    const watched = Array.from(this.watchers.keys()).map(p => path.basename(p));
    
    return {
      content: [{
        type: "text",
        text: watched.length > 0 
          ? `Watching ${watched.length} shaders:\n${watched.join('\n')}` 
          : "No shaders currently being watched"
      }]
    };
  }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("Hot Reload MCP server running");
  }
}

// Start server if run directly
if (require.main === module) {
  const tool = new HotReloadTool();
  tool.start().catch(console.error);
}
```





**Files Read:**

**/Users/erichowens/coding/metal-shader-mcp/WARP.md**
```
# WARP Agent Workflow Protocol

## üîÑ After-Action Requirements
**CRITICAL**: After every significant agent action, these steps MUST be completed:

### 1. **BUGS.md Update** 
- Document any issues discovered during the action
- Update status of existing bugs (resolved, persisting, or changed)
- Add new bugs with reproduction steps and context
- Include workarounds or partial solutions discovered

### 2. **CHANGELOG.md Entry**
- Record what was accomplished in this action
- Note any breaking changes or new features
- Document parameter changes, new shaders, or workflow improvements
- Include version info if applicable

### 3. **Visual Evidence Collection**
- Take screenshots of visual changes (REQUIRED for UI/shader work)
- Save visual artifacts to `Resources/screenshots/` with timestamps
- For shader work: capture before/after comparisons
- Document visual evidence in the changelog entry

### 4. **Git Operations**
- Stage and commit changes with descriptive commit messages
- Push to GitHub if working on shared features
- Create feature branches for experimental work
- Tag significant milestones

### 5. **Testing Validation**
- Run existing tests to ensure no regressions
- Create new tests for new functionality
- For visual work: implement or update visual regression tests
- Document test coverage changes

## ü§ñ Main Agent Responsibilities

As the primary development agent, you are responsible for all aspects of the project workflow. These responsibilities are organized by category but should be executed as a cohesive development process:

### Code Review & Quality
- Review all code changes before commit
- Ensure adherence to Metal and Swift best practices
- Verify shader optimization and performance
- Check parameter boundary conditions
- Provide honest assessment of changes
- Identify potential issues before they become bugs
- Validate visual output quality
- Ensure user experience improvements

### Documentation Management
- Maintain consistency across all .md files
- Update technical documentation as code evolves
- Keep API documentation current
- Ensure examples remain functional
- Document creative decisions and their rationale

### Task & Workflow Management
- Track completion of after-action requirements
- Ensure no steps are skipped in the workflow
- Maintain project momentum and focus
- Prioritize tasks based on dependencies and importance
- Create and manage todo lists when tasks require 3+ steps

### Metal Shader Specific
- Evaluate aesthetic quality of shader output
- Suggest artistic improvements
- Maintain visual consistency across shaders
- Monitor shader compilation times
- Profile GPU usage and memory consumption
- Identify optimization opportunities
- Ensure cross-device compatibility

## üì∏ Visual Testing Framework

### Required Visual Tests
1. **Shader Render Tests**: Capture output of each shader with standard parameters
2. **UI Component Tests**: Screenshot key UI states
3. **Parameter Change Tests**: Visual diff when parameters are adjusted
4. **Cross-Resolution Tests**: Ensure shaders work across display sizes

### Screenshot Naming Convention
```
Resources/screenshots/YYYY-MM-DD_HH-MM-SS_<feature>_<action>.png
Resources/screenshots/2024-09-06_09-15-30_plasma_shader_initial_render.png
Resources/screenshots/2024-09-06_09-16-45_ui_parameter_panel_expanded.png
```

### Visual Regression Testing
- Compare screenshots against baseline images
- Flag significant visual changes for manual review
- Maintain baseline image library
- Automate visual diff generation

## üîó Integration with Creative Process

### During Shader Development
1. **Baseline Capture**: Screenshot initial shader state
2. **Iterative Documentation**: Record each significant visual change
3. **Parameter Mapping**: Document visual effects of parameter changes
4. **Artistic Intent Recording**: Note creative goals and how they're achieved

### During Bug Fixes
1. **Problem Documentation**: Visual evidence of the issue
2. **Solution Verification**: Before/after screenshots
3. **Regression Prevention**: Add visual tests to prevent reoccurrence
4. **User Impact Assessment**: How fix improves user experience

## üéØ Success Metrics

### Documentation Quality
- All changes documented within 5 minutes of implementation
- Visual evidence provided for 100% of UI/shader changes  
- Git history provides clear narrative of project evolution
- No undocumented breaking changes

### Testing Coverage
- Every shader has visual regression tests
- UI components have screenshot-based tests
- Parameter changes are visually validated
- Cross-platform rendering verified

### Workflow Efficiency  
- After-action workflow completed in reasonable time (5-10 minutes for complex changes)
- No workflow steps skipped or forgotten
- Tasks prioritized and executed systematically
- Continuous improvement in process efficiency

## üõ† Tools and Commands

### CI Automation: EPIC Progress Sync
- The repository includes an automated CI workflow that posts progress comments to EPIC GitHub issues based on changed files and mappings.
- Source of truth for EPICs: `docs/EPICS.json` and mapping `docs/EPICS_MAP.json`.
- Script executed: `scripts/post_commit_sync.sh`
- Triggers: push to any branch, and PR events (opened, synchronize, reopened) on this repository.
- Authentication: uses GitHub Actions built-in `GITHUB_TOKEN` (scoped per-repo). No additional secrets required.
  - If cross-repo or org-wide posting is ever needed, create a fine-scoped PAT and store it as `EPIC_SYNC_TOKEN` in repository Secrets, then set `GH_TOKEN: ${{ secrets.EPIC_SYNC_TOKEN }}` in the workflow.
- Workflow file: `.github/workflows/epic-sync.yml`

### Screenshot Capture (macOS)
```bash
# Capture Metal Shader app window
./scripts/screenshot_app.sh "description"

# Manual capture selection
screencapture -s ~/path/to/screenshot.png

# Debug window issues
python3 scripts/debug_window.py

# Find window ID for debugging
python3 scripts/find_window_id.py
```

### Git Workflow
```bash
# Standard commit with visual evidence
git add .
git commit -m "feat: implement plasma shader variations

- Added 3 new plasma shader variants
- Enhanced parameter responsiveness  
- Visual evidence: Resources/screenshots/2024-09-06_plasma_variants.png
- Closes #issue-number"

git push origin feature/plasma-enhancements
```

### Test Execution
```bash
# Compile and run the Metal Shader app
swiftc -o MetalShaderStudio ShaderPlayground.swift \
  -framework SwiftUI \
  -framework MetalKit \
  -framework AppKit \
  -framework UniformTypeIdentifiers \
  -parse-as-library

./MetalShaderStudio &

# Capture screenshots for visual testing
./scripts/screenshot_app.sh "test_description"

# Run Swift tests (when implemented)
swift test --filter VisualRegressionTests

# Verify screenshot capture works
python3 scripts/find_window_id.py
```

## üö® Critical Failure Points

### Never Skip These Steps
1. **Visual evidence for visual changes** - Non-negotiable
2. **BUGS.md updates when issues found** - Must be immediate  
3. **CHANGELOG.md entries** - Required for all changes
4. **Git commits with descriptive messages** - Essential for history

### Red Flags
- Changes pushed without visual evidence
- Bugs discovered but not documented
- Code committed without testing
- Documentation left inconsistent
- Workflow steps completed out of order

---

*This workflow ensures that every action builds toward a more robust, well-documented, and visually stunning shader development environment. The discipline of visual evidence and systematic documentation transforms development from ad-hoc exploration into purposeful artistic and technical progress. While originally designed for multiple agents, this workflow has been adapted for efficient execution by a single primary agent handling all responsibilities.*

---

**Last Updated**: 2025-09-07  
**Project Structure**: ShaderPlayground.swift as main application file  
**Key Changes**: Consolidated multi-agent workflow into single agent responsibilities

```





**Files Read:**

**/Users/erichowens/coding/metal-shader-mcp/scripts/screenshot_app.sh**
```
#!/bin/bash

# BULLETPROOF MetalShaderStudio Screenshot Script
# Usage: ./scripts/screenshot_app.sh [description] [--expect-tab <repl|library|projects|tools|history>]

APP_NAME="ShaderPlayground"
SCREENSHOT_DIR="Resources/screenshots"
TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
EXPECT_TAB=""

# Parse args (simple)
DESC=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --expect-tab)
      EXPECT_TAB="$2"; shift 2;;
    *)
      if [[ -z "$DESC" ]]; then DESC="$1"; else DESC="$DESC $1"; fi; shift;;
  esac
done

if [[ -z "$DESC" ]]; then DESC="app"; fi
# Replace spaces with underscores for filename
DESC="${DESC// /_}"

# Create directory
mkdir -p "$SCREENSHOT_DIR"

# Filename
OUTPUT_FILE="$SCREENSHOT_DIR/${TIMESTAMP}_${DESC}.png"

# Optional: verify expected tab from status.json
if [[ -n "$EXPECT_TAB" ]]; then
  echo "üîé Verifying selected tab = '$EXPECT_TAB'"
  STATUS_FILE="Resources/communication/status.json"
  ATTEMPTS=0; MAX_ATTEMPTS=30
  while [[ $ATTEMPTS -lt $MAX_ATTEMPTS ]]; do
    if [[ -f "$STATUS_FILE" ]]; then
      CURRENT=$(jq -r '.current_tab // empty' "$STATUS_FILE" 2>/dev/null || true)
      if [[ "$CURRENT" == "$EXPECT_TAB" ]]; then
        echo "‚úÖ current_tab matches ($CURRENT)"; break
      fi
    fi
    ATTEMPTS=$((ATTEMPTS+1)); sleep 0.1
  done
  if [[ "$CURRENT" != "$EXPECT_TAB" ]]; then
    echo "‚ùå Expected tab '$EXPECT_TAB' but status shows '$CURRENT' or missing" >&2
    exit 2
  fi
fi

echo "üì∏ Capturing $APP_NAME window using CGWindowID..."

# Get the actual CGWindowID using our Swift script
WINDOW_ID=$(python3 "$(dirname "$0")/find_window_id.py" 2>/dev/null | tail -1)

if [[ "$WINDOW_ID" =~ ^[0-9]+$ ]]; then
    echo "‚úÖ Found CGWindowID: $WINDOW_ID"
    
    # Capture the window using the CGWindowID (works even if window is behind others)
    screencapture -l"$WINDOW_ID" -o "$OUTPUT_FILE"
    
    if [ -f "$OUTPUT_FILE" ]; then
        FILE_SIZE=$(stat -f%z "$OUTPUT_FILE")
        echo "‚úÖ Screenshot saved: $OUTPUT_FILE"
        echo "üìä File size: $FILE_SIZE bytes"
        
        # Verify it's not empty
        if [ "$FILE_SIZE" -gt 1000 ]; then
            echo "üîç Opening screenshot..."
            open "$OUTPUT_FILE"
            echo "‚ú® SUCCESS! Window captured even if it was in background."
            exit 0
        else
            echo "‚ö†Ô∏è Warning: Screenshot file seems too small"
            exit 1
        fi
    else
        echo "‚ùå Screenshot file not created"
        exit 1
    fi
else
    echo "‚ùå Could not get CGWindowID: $WINDOW_ID"
    echo "üîÑ Make sure $APP_NAME is running"
    exit 1
fi

```

**/Users/erichowens/coding/metal-shader-mcp/scripts/set_tab.sh**
```
#!/usr/bin/env bash
set -euo pipefail
TAB="${1:-history}"
mkdir -p Resources/communication
cat > Resources/communication/commands.json <<JSON
{
  "action": "set_tab",
  "tab": "${TAB}",
  "timestamp": $(date +%s)
}
JSON


```

**/Users/erichowens/coding/metal-shader-mcp/scripts/find_window_id.py**
```
#!/usr/bin/env python3
"""
Find CGWindowID for MetalShaderStudio using PyObjC (built into macOS Python)
"""

import subprocess
import json
import sys
import os

def get_window_id_via_applescript():
    """Alternative method using AppleScript to get process info"""
    script = '''
    tell application "System Events"
        tell process "ShaderPlayground"
            if exists window 1 then
                return {name of window 1, id of window 1}
            else
                return "no window"
            end if
        end tell
    end tell
    '''
    try:
        result = subprocess.run(['osascript', '-e', script], 
                              capture_output=True, text=True, timeout=10)
        return result.stdout.strip()
    except:
        return None

def get_window_id_via_swift():
    """Use Swift to get CGWindowID - most reliable method"""
    swift_code = '''
import Cocoa
import CoreGraphics

let windowList = CGWindowListCopyWindowInfo(.excludeDesktopElements, kCGNullWindowID) as! [[String: Any]]

// First pass: look for visible windows with names
for window in windowList {
    if let ownerName = window["kCGWindowOwnerName"] as? String,
       let windowID = window["kCGWindowNumber"] as? Int {
        
        if ownerName.contains("ShaderPlayground") || ownerName.contains("MetalShaderStudio") {
            let windowName = window["kCGWindowName"] as? String ?? ""
            let isOnScreen = window["kCGWindowIsOnscreen"] as? Bool ?? false
            
            // Prioritize visible windows with names
            if isOnScreen && !windowName.isEmpty {
                print("\\(windowID)")
                exit(0)
            }
        }
    }
}

// Second pass: any visible MetalShaderStudio window
for window in windowList {
    if let ownerName = window["kCGWindowOwnerName"] as? String,
       let windowID = window["kCGWindowNumber"] as? Int {
        
        if ownerName.contains("ShaderPlayground") || ownerName.contains("MetalShaderStudio") {
            let isOnScreen = window["kCGWindowIsOnscreen"] as? Bool ?? false
            
            if isOnScreen {
                print("\\(windowID)")
                exit(0)
            }
        }
    }
}

exit(1)
'''
    
    # Write Swift code to temp file
    swift_file = "/tmp/find_window.swift"
    with open(swift_file, 'w') as f:
        f.write(swift_code)
    
    try:
        # Compile and run Swift code
        result = subprocess.run(['swift', swift_file], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            window_id = result.stdout.strip()
            if window_id.isdigit():
                return int(window_id)
        return None
    except Exception as e:
        print(f"Swift method failed: {e}")
        return None
    finally:
        # Clean up
        if os.path.exists(swift_file):
            os.remove(swift_file)

def main():
    print("üîç Searching for ShaderPlayground window ID...")
    
    # Method 1: Try Swift approach (most reliable)
    window_id = get_window_id_via_swift()
    if window_id:
        print(f"‚úÖ Found CGWindowID via Swift: {window_id}")
        return window_id
    
    print("‚ö†Ô∏è Swift method failed, trying alternative approaches...")
    
    # Method 2: Try AppleScript (less reliable but worth trying)
    result = get_window_id_via_applescript()
    if result and result != "no window":
        print(f"üìã AppleScript result: {result}")
    
    print("‚ùå Could not find reliable CGWindowID")
    return None

if __name__ == "__main__":
    window_id = main()
    if window_id:
        print(window_id)
        sys.exit(0)
    else:
        sys.exit(1)

```

**/Users/erichowens/coding/metal-shader-mcp/scripts/debug_window.py**
```
#!/usr/bin/env python3
"""
Debug window properties for MetalShaderStudio
"""

import subprocess
import sys
import os

def debug_window_via_swift():
    """Get detailed window info using Swift"""
    swift_code = '''
import Cocoa
import CoreGraphics

let windowList = CGWindowListCopyWindowInfo(.excludeDesktopElements, kCGNullWindowID) as! [[String: Any]]

print("=== All MetalShaderStudio Windows ===")
var foundCount = 0

for window in windowList {
    if let ownerName = window["kCGWindowOwnerName"] as? String,
       let windowID = window["kCGWindowNumber"] as? Int {
        
        if ownerName.contains("MetalShaderStudio") {
            foundCount += 1
            let windowName = window["kCGWindowName"] as? String ?? "No Name"
            let bounds = window["kCGWindowBounds"] as? [String: Any] ?? [:]
            let layer = window["kCGWindowLayer"] as? Int ?? 0
            let alpha = window["kCGWindowAlpha"] as? Double ?? 1.0
            let isOnScreen = window["kCGWindowIsOnscreen"] as? Bool ?? false
            let ownerPID = window["kCGWindowOwnerPID"] as? Int ?? 0
            
            print("Window #\\(foundCount):")
            print("  ID: \\(windowID)")
            print("  Name: '\\(windowName)'")
            print("  Owner: \\(ownerName)")
            print("  PID: \\(ownerPID)")
            print("  Layer: \\(layer)")
            print("  Alpha: \\(alpha)")
            print("  OnScreen: \\(isOnScreen)")
            print("  Bounds: \\(bounds)")
            print("  ---")
        }
    }
}

if foundCount == 0 {
    print("No MetalShaderStudio windows found!")
} else {
    print("Found \\(foundCount) MetalShaderStudio windows")
}
'''
    
    # Write Swift code to temp file
    swift_file = "/tmp/debug_window.swift"
    with open(swift_file, 'w') as f:
        f.write(swift_code)
    
    try:
        # Compile and run Swift code
        result = subprocess.run(['swift', swift_file], 
                              capture_output=True, text=True, timeout=10)
        return result.stdout, result.stderr
    except Exception as e:
        return None, f"Swift method failed: {e}"
    finally:
        # Clean up
        if os.path.exists(swift_file):
            os.remove(swift_file)

def main():
    print("üîç Debugging MetalShaderStudio windows...")
    
    stdout, stderr = debug_window_via_swift()
    if stdout:
        print(stdout)
    if stderr:
        print("Errors:", stderr)

if __name__ == "__main__":
    main()

```

**/Users/erichowens/coding/metal-shader-mcp/scripts/ci/ui_smoke.sh**
```
#!/usr/bin/env bash
set -euo pipefail

# CI UI smoke: build, launch History tab, verify status.json current_tab
ROOT_DIR=$(cd "$(dirname "$0")/../.." && pwd)
cd "$ROOT_DIR"

# Ensure deps for scripts
if ! command -v jq >/dev/null 2>&1; then
  echo "Installing jq..."
  brew update >/dev/null 2>&1 || true
  brew install jq >/dev/null 2>&1 || true
fi

# Build
swiftc -o MetalShaderStudio \
  ShaderPlayground.swift AppShellView.swift HistoryTabView.swift SessionRecorder.swift \
  -framework SwiftUI -framework MetalKit -framework AppKit -framework UniformTypeIdentifiers \
  -parse-as-library

# Clean comm dir
rm -f Resources/communication/status.json || true
mkdir -p Resources/communication

# Launch into history tab
./MetalShaderStudio --tab history >/dev/null 2>&1 &
APP_PID=$!
# Give it time to boot
sleep 2

# Verify status.json
if [[ ! -f Resources/communication/status.json ]]; then
  echo "‚ùå status.json not written" >&2
  kill $APP_PID || true
  exit 1
fi
TAB=$(jq -r '.current_tab // empty' Resources/communication/status.json)
if [[ "$TAB" != "history" ]]; then
  echo "‚ùå Expected history tab, got '$TAB'" >&2
  kill $APP_PID || true
  exit 1
fi

echo "‚úÖ current_tab=history"

# Try a best-effort screenshot (non-fatal)
if [[ -x scripts/screenshot_app.sh ]]; then
  set +e
  ./scripts/screenshot_app.sh "ci_history" --expect-tab history || echo "‚ö†Ô∏è Screenshot step failed (non-fatal)"
  set -e
fi

# Cleanup app process
kill $APP_PID || true
exit 0

```

**/Users/erichowens/coding/metal-shader-mcp/HistoryTabView.swift**
```
import SwiftUI

@MainActor
final class SessionStore: ObservableObject {
    @Published var sessions: [Session] = []
    private let baseDir = "Resources/sessions"

    struct Session: Identifiable {
        let id: String
        let path: String
        let createdAt: Date
        let snapshots: [Snapshot]
    }

    struct Snapshot: Identifiable {
        let id: String
        let jsonPath: String
        let codePath: String
        let imagePath: String?
        let timestamp: Date
        let errors: Int
        let warnings: Int
        let label: String?
    }

    init() {
        ensureBaseDir()
        reload()
    }

    func reload() {
        ensureBaseDir()
        var result: [Session] = []
        let fm = FileManager.default
        guard let entries = try? fm.contentsOfDirectory(atPath: baseDir) else {
            sessions = []
            return
        }
        for entry in entries.sorted() { // timestamped dirs
            let sessionPath = baseDir + "/" + entry
            var isDir: ObjCBool = false
            if fm.fileExists(atPath: sessionPath, isDirectory: &isDir), isDir.boolValue {
                let sessionJson = sessionPath + "/session.json"
                let createdAt = Self.readCreatedAt(sessionJson: sessionJson)
                let snaps = Self.readSnapshots(sessionPath: sessionPath)
                result.append(Session(id: entry, path: sessionPath, createdAt: createdAt, snapshots: snaps))
            }
        }
        // Sort newest first
        sessions = result.sorted { $0.createdAt > $1.createdAt }
    }

    private func ensureBaseDir() {
        try? FileManager.default.createDirectory(atPath: baseDir, withIntermediateDirectories: true)
    }

    private static func readCreatedAt(sessionJson: String) -> Date {
        if let data = try? Data(contentsOf: URL(fileURLWithPath: sessionJson)),
           let obj = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let ts = obj["created_at"] as? TimeInterval {
            return Date(timeIntervalSince1970: ts)
        }
        return Date.distantPast
    }

    private static func readSnapshots(sessionPath: String) -> [Snapshot] {
        let snapsDir = sessionPath + "/snapshots"
        let fm = FileManager.default
        guard let files = try? fm.contentsOfDirectory(atPath: snapsDir) else { return [] }
        // Group by basename snap_XXXX
        let bases = Set(files.compactMap { name -> String? in
            if name.hasSuffix(".json") || name.hasSuffix(".metal") || name.hasSuffix(".png") {
                return String(name.split(separator: ".").first!)
            }
            return nil
        })
        var snaps: [Snapshot] = []
        for base in bases {
            let jsonPath = snapsDir + "/" + base + ".json"
            let codePath = snapsDir + "/" + base + ".metal"
            let pngPath = snapsDir + "/" + base + ".png"
            let meta = readSnapshotMeta(jsonPath: jsonPath)
            let ts = meta.timestamp
            let snap = Snapshot(id: base,
                                jsonPath: jsonPath,
                                codePath: codePath,
                                imagePath: FileManager.default.fileExists(atPath: pngPath) ? pngPath : nil,
                                timestamp: ts,
                                errors: meta.errors,
                                warnings: meta.warnings,
                                label: meta.label)
            snaps.append(snap)
        }
        // Sort by time ascending within session
        return snaps.sorted { $0.timestamp < $1.timestamp }
    }

    func createEmptySession(note: String) {
        ensureBaseDir()
        let df = DateFormatter()
        df.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let stamp = df.string(from: Date())
        let sid = "session_\(stamp)"
        let sessionDir = baseDir + "/" + sid
        let snapsDir = sessionDir + "/snapshots"
        try? FileManager.default.createDirectory(atPath: snapsDir, withIntermediateDirectories: true)
        let meta: [String: Any] = [
            "id": sid,
            "created_at": Date().timeIntervalSince1970,
            "app": "ShaderPlayground",
            "notes": note
        ]
        if let data = try? JSONSerialization.data(withJSONObject: meta, options: [.prettyPrinted]) {
            try? data.write(to: URL(fileURLWithPath: sessionDir + "/session.json"))
        }
        // touch timeline
        FileManager.default.createFile(atPath: sessionDir + "/timeline.jsonl", contents: nil)
        reload()
    }

    private static func readSnapshotMeta(jsonPath: String) -> (timestamp: Date, errors: Int, warnings: Int, label: String?) {
        guard let data = try? Data(contentsOf: URL(fileURLWithPath: jsonPath)),
              let obj = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            return (Date.distantPast, 0, 0, nil)
        }
        let ts = (obj["timestamp"] as? TimeInterval).map(Date.init(timeIntervalSince1970:)) ?? Date.distantPast
        let errors = obj["errors"] as? Int ?? 0
        let warnings = obj["warnings"] as? Int ?? 0
        // label comes from timeline; optional, not required in meta json
        let label = obj["label"] as? String
        return (ts, errors, warnings, label)
    }
}

struct HistoryTabView: View {
    @StateObject private var store = SessionStore()
    @State private var selectedKeys: Set<String> = []
    @State private var showCompare: Bool = false
    @State private var searchText: String = ""

    var body: some View {
        NavigationView {
            if store.sessions.isEmpty {
                VStack(spacing: 12) {
                    Text("No sessions found")
                        .font(.title3)
                    Text("Open the REPL and make a change, or create an empty session.")
                        .foregroundStyle(.secondary)
                    HStack {
                        Button(action: { store.createEmptySession(note: "manual") }) { Label("Create Empty Session", systemImage: "plus") }
                        Button(action: { store.reload() }) { Label("Reload", systemImage: "arrow.clockwise") }
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
            List {
                ForEach(filteredSessions()) { session in
                    Section(header: HStack {
                        Text(session.id)
                        Spacer()
                        Text(Self.fmt(session.createdAt))
                            .foregroundStyle(.secondary)
                    }) {
                        if session.snapshots.isEmpty {
                            Text("No snapshots yet").foregroundStyle(.secondary)
                        } else {
                            ScrollView(.horizontal, showsIndicators: true) {
                                HStack(alignment: .top, spacing: 12) {
                                    ForEach(filteredSnapshots(in: session)) { snap in
                                        SnapshotCard(snapshot: snap,
                                                     uniqueKey: "\(session.id)/\(snap.id)",
                                                     selectedKeys: $selectedKeys)
                                    }
                                }.padding(.vertical, 6)
                            }.frame(height: 160)
                        }
                    }
                }
            }
            .navigationTitle("Session Browser")
            .toolbar {
                ToolbarItemGroup(placement: .primaryAction) {
                    Button(action: { store.reload() }) { Label("Reload", systemImage: "arrow.clockwise") }
                    Button(action: { showCompare = true }) { Label("Compare", systemImage: "rectangle.split.2x1") }
                        .disabled(selectedKeys.count != 2)
                        .help("Compare two selected snapshots")
                }
            }
        }
        .searchable(text: $searchText)
        .sheet(isPresented: $showCompare) { CompareSheet(selectedKeys: Array(selectedKeys), store: store) }
    }

    private func filteredSessions() -> [SessionStore.Session] {
        guard !searchText.isEmpty else { return store.sessions }
        let term = searchText.lowercased()
        return store.sessions.compactMap { s in
            let snapMatches = s.snapshots.filter { $0.id.lowercased().contains(term) || (s.id.lowercased().contains(term)) }
            if !snapMatches.isEmpty || s.id.lowercased().contains(term) {
                return SessionStore.Session(id: s.id, path: s.path, createdAt: s.createdAt, snapshots: snapMatches.isEmpty ? s.snapshots : snapMatches)
            }
            return nil
        }
    }

    private func filteredSnapshots(in session: SessionStore.Session) -> [SessionStore.Snapshot] {
        guard !searchText.isEmpty else { return session.snapshots }
        let term = searchText.lowercased()
        return session.snapshots.filter { $0.id.lowercased().contains(term) }
    }

    private static func fmt(_ d: Date) -> String {
        let df = DateFormatter()
        df.dateStyle = .medium
        df.timeStyle = .short
        return df.string(from: d)
    }
}

struct SnapshotCard: View {
    let snapshot: SessionStore.Snapshot
    let uniqueKey: String
    @Binding var selectedKeys: Set<String>

    var body: some View {
        VStack(spacing: 6) {
            ZStack(alignment: .topTrailing) {
                ThumbnailView(imagePath: snapshot.imagePath)
                    .frame(width: 140, height: 120)
                    .clipped()
                    .cornerRadius(6)
                    .overlay(RoundedRectangle(cornerRadius: 6).stroke(Color.gray.opacity(0.2)))
                if snapshot.errors > 0 {
                    Label("\(snapshot.errors)", systemImage: "exclamationmark.triangle.fill")
                        .font(.caption2)
                        .padding(4)
                        .background(.yellow.opacity(0.9))
                        .cornerRadius(4)
                        .padding(4)
                }
            }
            HStack {
                Text(snapshot.id)
                    .font(.caption)
                    .lineLimit(1)
                Spacer()
                Button(action: { toggleSelect() }) {
                    Image(systemName: selectedKeys.contains(uniqueKey) ? "checkmark.circle.fill" : "circle")
                        .help("Select for compare")
                }.buttonStyle(.plain)
                Button(action: openInREPL) {
                    Image(systemName: "arrow.turn.down.left")
                        .help("Open in REPL (records snapshot)")
                }.buttonStyle(.plain)
                Button(action: openInREPLSilent) {
                    Image(systemName: "eye.slash")
                        .help("Open in REPL (no snapshot)")
                }.buttonStyle(.plain)
            }
            .frame(width: 140)
        }
        .frame(width: 150)
    }

    private func toggleSelect() {
        if selectedKeys.contains(uniqueKey) { selectedKeys.remove(uniqueKey) } else { selectedKeys.insert(uniqueKey) }
    }

    private func openInREPL() {
        // Read code
        guard let code = try? String(contentsOfFile: snapshot.codePath, encoding: .utf8) else { return }
        // Write uniforms.json if snapshot meta has uniforms (optional)
        // Stepwise optional unwrapping with error handling
        if let jsonData = try? Data(contentsOf: URL(fileURLWithPath: snapshot.jsonPath)) {
            do {
                if let jsonObject = try JSONSerialization.jsonObject(with: jsonData) as? [String: Any] {
                    if let uniforms = jsonObject["uniforms"] as? [String: Any] {
                        let obj: [String: Any] = ["uniforms": uniforms, "timestamp": Date().timeIntervalSince1970]
                        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
                            try? data.write(to: URL(fileURLWithPath: "Resources/communication/uniforms.json"))
                        }
                    } else {
                        print("Warning: 'uniforms' key not found or not a dictionary in \(snapshot.jsonPath)")
                    }
                } else {
                    print("Warning: JSON root is not a dictionary in \(snapshot.jsonPath)")
                }
            } catch {
                print("Error parsing JSON from \(snapshot.jsonPath): \(error)")
            }
        } else {
            print("Warning: Could not read data from \(snapshot.jsonPath)")
        }
        // Send set_shader command via bridge
        let cmd: [String: Any] = [
            "action": "set_shader",
            "shader_code": code,
            "description": "open_snapshot \(snapshot.id)",
            "timestamp": Date().timeIntervalSince1970,
            "no_snapshot": false
        ]
        if let data = try? JSONSerialization.data(withJSONObject: cmd, options: [.prettyPrinted]) {
            try? FileManager.default.createDirectory(atPath: "Resources/communication", withIntermediateDirectories: true)
            try? data.write(to: URL(fileURLWithPath: "Resources/communication/commands.json"))
        }
    }

    private func openInREPLSilent() {
        guard let code = try? String(contentsOfFile: snapshot.codePath, encoding: .utf8) else { return }
        let cmd: [String: Any] = [
            "action": "set_shader",
            "shader_code": code,
            "description": "open_snapshot_silent \(snapshot.id)",
            "timestamp": Date().timeIntervalSince1970,
            "no_snapshot": true
        ]
        if let data = try? JSONSerialization.data(withJSONObject: cmd, options: [.prettyPrinted]) {
            try? FileManager.default.createDirectory(atPath: "Resources/communication", withIntermediateDirectories: true)
            try? data.write(to: URL(fileURLWithPath: "Resources/communication/commands.json"))
        }
    }
}

struct ThumbnailView: View {
    let imagePath: String?
    var body: some View {
        Group {
            if let path = imagePath, let nsimg = NSImage(contentsOfFile: path) {
                Image(nsImage: nsimg)
                    .resizable()
                    .scaledToFill()
            } else {
                ZStack {
                    Color.black.opacity(0.1)
                    Image(systemName: "photo")
                        .font(.largeTitle)
                        .foregroundStyle(.secondary)
                }
            }
        }
    }
}

struct CompareSheet: View {
    let selectedKeys: [String]
    let store: SessionStore

    private func lookup(_ key: String) -> (SessionStore.Session, SessionStore.Snapshot)? {
        let parts = key.split(separator: "/", maxSplits: 1).map(String.init)
        guard parts.count == 2 else { return nil }
        let sessionId = parts[0], snapId = parts[1]
        guard let session = store.sessions.first(where: { $0.id == sessionId }),
              let snap = session.snapshots.first(where: { $0.id == snapId }) else { return nil }
        return (session, snap)
    }

    var body: some View {
        VStack(spacing: 12) {
            Text("Compare Snapshots")
                .font(.headline)
            HStack(spacing: 10) {
                ForEach(selectedKeys.prefix(2), id: \.self) { key in
                    if let (_, snap) = lookup(key) {
                        VStack(spacing: 6) {
                            ThumbnailView(imagePath: snap.imagePath)
                                .frame(width: 240, height: 200)
                                .clipped()
                                .cornerRadius(8)
                                .overlay(RoundedRectangle(cornerRadius: 8).stroke(Color.gray.opacity(0.3)))
                            Text("\(snap.id)")
                                .font(.caption)
                        }
                    }
                }
            }
            .padding(.horizontal)
            HStack {
                Button("Close") {
                    if let keyWindow = NSApp.keyWindow {
                        keyWindow.endSheet(keyWindow)
                    }
                }
            }
            .padding(.bottom)
        }
        .padding()
        .frame(minWidth: 540, minHeight: 320)
    }
}


```

**/Users/erichowens/coding/metal-shader-mcp/AppShellView.swift**
```
import SwiftUI

// Shared enum for app tabs
enum AppTab: String, Hashable, CaseIterable { case repl, library, projects, tools, history }

final class AppState: ObservableObject {
    @Published var selectedTab: AppTab = .repl
}

struct AppShellView: View {
    @EnvironmentObject var appState: AppState
    let initialTab: AppTab

    init(initialTab: AppTab = .repl) {
        self.initialTab = initialTab
    }

    var body: some View {
        TabView(selection: $appState.selectedTab) {
            // REPL: Use the existing ContentView to avoid breaking behavior
            ContentView()
                .tabItem { Label("REPL", systemImage: "sparkles") }
                .tag(AppTab.repl)

            LibraryView()
                .tabItem { Label("Library", systemImage: "books.vertical") }
                .tag(AppTab.library)

            ProjectsView()
                .tabItem { Label("Projects", systemImage: "folder") }
                .tag(AppTab.projects)

            MCPToolsView()
                .tabItem { Label("MCP Tools", systemImage: "wrench.and.screwdriver") }
                .tag(AppTab.tools)

            HistoryTabView()
                .tabItem { Label("History", systemImage: "clock.arrow.circlepath") }
                .tag(AppTab.history)
        }
        .onAppear {
            // Set initial tab once at startup
            if AppTab.allCases.contains(initialTab) {
                appState.selectedTab = initialTab
            }
            writeSelectedTabStatus()
        }
        .onChange(of: appState.selectedTab) { _ in
            writeSelectedTabStatus()
        }
    }

    private func writeSelectedTabStatus() {
        let obj: [String: Any] = [
            "current_tab": appState.selectedTab.rawValue,
            "timestamp": Date().timeIntervalSince1970
        ]
        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
            try? FileManager.default.createDirectory(atPath: "Resources/communication", withIntermediateDirectories: true)
            try? data.write(to: URL(fileURLWithPath: "Resources/communication/status.json"))
        }
    }
}

// MARK: - Placeholder Views (scaffolding)
struct LibraryView: View {
    var body: some View {
        VStack(spacing: 16) {
            Text("Educational Shader Library")
                .font(.title2)
            Text("Curated examples, annotations, presets. Coming soon.")
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

struct ProjectsView: View {
    var body: some View {
        VStack(spacing: 16) {
            Text("Projects")
                .font(.title2)
            Text("Track snapshots, variants, and generational progress. Coming soon.")
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

struct MCPToolsView: View {
    var body: some View {
        VStack(spacing: 16) {
            Text("MCP Tool Explorer")
                .font(.title2)
            Text("Browse tools, view JSON schemas, run tools with arguments. Coming soon.")
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

struct HistoryPlaceholderView: View {
    var body: some View {
        VStack(spacing: 16) {
            Text("History")
                .font(.title2)
            Text("Timeline of edits, tool invocations, and screenshots. Coming soon.")
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}


```

**/Users/erichowens/coding/metal-shader-mcp/SessionRecorder.swift**
```
import Foundation
import CryptoKit
import Combine
import SwiftUI

final class SessionRecorder: ObservableObject {
    private let baseDir = "Resources/sessions"
    private(set) var sessionId: String
    private let sessionDir: String
    private let snapshotsDir: String
    private var snapshotCounter: Int = 0
    private let fileManager = FileManager.default

    init() {
        // Create a new session directory with timestamp
        let df = DateFormatter()
        df.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let stamp = df.string(from: Date())
        self.sessionId = "session_\(stamp)"
        self.sessionDir = "\(baseDir)/\(sessionId)"
        self.snapshotsDir = "\(sessionDir)/snapshots"
        try? fileManager.createDirectory(atPath: snapshotsDir, withIntermediateDirectories: true)
        // Write session.json
        let sessionMeta: [String: Any] = [
            "id": sessionId,
            "created_at": Date().timeIntervalSince1970,
            "app": "ShaderPlayground",
            "notes": "Auto-created session"
        ]
        writeJSON(sessionMeta, to: "\(sessionDir)/session.json")
    }

    func recordSnapshot(code: String, renderer: MetalShaderRenderer, label: String? = nil, uniforms: [String: Any]? = nil) {
        snapshotCounter += 1
        let snapId = String(format: "snap_%04d", snapshotCounter)
        let codePath = "\(snapshotsDir)/\(snapId).metal"
        try? code.write(toFile: codePath, atomically: true, encoding: .utf8)

        // Hash code for identity
        let codeHash = Self.sha256Hex(of: code)

        // Ask renderer to export a frame with a unique description
        let exportDesc = "\(sessionId)_\(snapId)"
        renderer.exportFrame(description: exportDesc)

        // Poll Resources/exports to find the output PNG and copy it into the session
        let exportedPath = waitForLatestExport(matching: exportDesc, timeoutSec: 3.0)
        var sessionImagePath: String? = nil
        if let exportedPath = exportedPath {
            let dest = "\(snapshotsDir)/\(snapId).png"
            do { try fileManager.copyItem(atPath: exportedPath, toPath: dest); sessionImagePath = dest } catch {
                // If already exists, overwrite
                _ = try? fileManager.removeItem(atPath: dest)
                _ = try? fileManager.copyItem(atPath: exportedPath, toPath: dest)
                sessionImagePath = dest
            }
        }

        // Read last compilation errors if available
        var errCount = 0
        var warnCount = 0
        if let data = try? Data(contentsOf: URL(fileURLWithPath: "Resources/communication/compilation_errors.json")),
           let obj = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            if let arr = obj["errors"] as? [Any] { errCount = arr.count }
            if let arr = obj["warnings"] as? [Any] { warnCount = arr.count }
        }

        // Build snapshot metadata
        var meta: [String: Any] = [
            "id": snapId,
            "timestamp": Date().timeIntervalSince1970,
            "code_hash": codeHash,
            "code_path": codePath,
            "image_path": sessionImagePath ?? NSNull(),
            "errors": errCount,
            "warnings": warnCount
        ]
        if let uniforms = uniforms { meta["uniforms"] = uniforms }
        writeJSON(meta, to: "\(snapshotsDir)/\(snapId).json")

        // Append to session timeline jsonl
        let timelineEntry: [String: Any] = [
            "event": "snapshot",
            "id": snapId,
            "label": label ?? "",
            "image": sessionImagePath ?? "",
            "time": Date().timeIntervalSince1970
        ]
        appendJSONLine(timelineEntry, to: "\(sessionDir)/timeline.jsonl")
    }

    func recordEvent(_ name: String, payload: [String: Any] = [:]) {
        var entry: [String: Any] = ["event": name, "time": Date().timeIntervalSince1970]
        payload.forEach { entry[$0.key] = $0.value }
        appendJSONLine(entry, to: "\(sessionDir)/timeline.jsonl")
    }

    // MARK: - Helpers
    private func writeJSON(_ obj: [String: Any], to path: String) {
        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
            try? data.write(to: URL(fileURLWithPath: path))
        }
    }

    private func appendJSONLine(_ obj: [String: Any], to path: String) {
        guard let data = try? JSONSerialization.data(withJSONObject: obj, options: []) else { return }
        if !fileManager.fileExists(atPath: path) { fileManager.createFile(atPath: path, contents: nil) }
        if let handle = try? FileHandle(forWritingTo: URL(fileURLWithPath: path)) {
            defer { try? handle.close() }
            handle.seekToEndOfFile()
            handle.write(data)
            if let newlineData = "\n".data(using: .utf8) {
                handle.write(newlineData)
            }
        }
    }

    private func waitForLatestExport(matching desc: String, timeoutSec: TimeInterval) -> String? {
        let dir = "Resources/exports"
        let start = Date()
        while Date().timeIntervalSince(start) < timeoutSec {
            if let path = latestPNG(in: dir, containing: desc) { return path }
            RunLoop.current.run(until: Date().addingTimeInterval(0.1))
        }
        return nil
    }

    private func latestPNG(in dir: String, containing token: String) -> String? {
        guard let items = try? fileManager.contentsOfDirectory(atPath: dir) else { return nil }
        let matches = items.filter { $0.hasSuffix(".png") && $0.contains(token) }
        guard matches.count > 0 else { return nil }
        let urls = matches.map { URL(fileURLWithPath: "\(dir)/\($0)") }
        let sorted = urls.sorted { (a, b) -> Bool in
            let at = (try? a.resourceValues(forKeys: [.contentModificationDateKey]).contentModificationDate) ?? Date.distantPast
            let bt = (try? b.resourceValues(forKeys: [.contentModificationDateKey]).contentModificationDate) ?? Date.distantPast
            return at > bt
        }
        return sorted.first?.path
    }

    private static func sha256Hex(of text: String) -> String {
        let data = Data(text.utf8)
        let hash = SHA256.hash(data: data)
        return hash.compactMap { String(format: "%02x", $0) }.joined()
    }
}

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/visual-tests.yml**
```
name: Visual Testing and Evidence Capture

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  visual-tests:
    name: Visual Testing and Screenshot Capture
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Build with SwiftPM
      run: |
        echo "Building with Swift Package Manager (debug)..."
        swift build --configuration debug
    
    - name: Prepare evidence directory
      run: |
        mkdir -p Resources/screenshots
        mkdir -p visual-test-output
        echo "Prepared directories for visual evidence"
    
    # Skipping heavy placeholder generation to keep CI fast
    
    # Baseline comparison intentionally skipped for speed; future tool will handle diffs
    
    # Naming convention checks skipped: naming hints remain in docs, not enforced in CI
    
    # Skipping PNG optimization to reduce CI time
    
    - name: Generate visual test report
      run: |
        echo "Generating visual test report..."
        
        SCREENSHOT_COUNT=$(find Resources/screenshots -name "*.png" | wc -l)
        TOTAL_SIZE=$(du -sh Resources/screenshots | cut -f1)
        
        cat > visual-test-report.md << EOF
        # Visual Testing Report
        
        **Test Date**: $(date)
        **Total Screenshots**: $SCREENSHOT_COUNT
        **Total Size**: $TOTAL_SIZE
        
        ## Screenshots Captured
        EOF
        
        for screenshot in Resources/screenshots/*.png; do
          if [ -f "$screenshot" ]; then
            filename=$(basename "$screenshot")
            size=$(ls -lh "$screenshot" | awk '{print $5}')
            echo "- \`$filename\` ($size)" >> visual-test-report.md
          fi
        done
        
        echo "" >> visual-test-report.md
        echo "## Status" >> visual-test-report.md
        echo "- ‚úÖ Visual evidence capture completed" >> visual-test-report.md
        echo "- ‚úÖ WARP.md naming conventions validated" >> visual-test-report.md
        echo "- ‚úÖ Images optimized for storage" >> visual-test-report.md
    
    - name: Upload visual artifacts
      uses: actions/upload-artifact@v4
      with:
        name: visual-test-evidence
        path: |
          Resources/screenshots/
          visual-test-report.md
        retention-days: 30
    
    - name: Visual testing summary
      run: |
        echo "## üì∏ Visual Testing Summary" >> $GITHUB_STEP_SUMMARY
        echo "### Evidence Captured" >> $GITHUB_STEP_SUMMARY
        SCREENSHOT_COUNT=$(find Resources/screenshots -name "*.png" | wc -l)
        echo "- üì∏ Screenshots captured: $SCREENSHOT_COUNT" >> $GITHUB_STEP_SUMMARY
        echo "- üéØ WARP.md naming conventions: ‚úÖ Validated" >> $GITHUB_STEP_SUMMARY
        echo "- üóúÔ∏è Image optimization: ‚úÖ Complete" >> $GITHUB_STEP_SUMMARY
        echo "- üì¶ Artifacts uploaded: ‚úÖ Available for 30 days" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Files Generated" >> $GITHUB_STEP_SUMMARY
        find Resources/screenshots -name "*.png" | head -10 | sed 's|^|‚Ä¢ |' >> $GITHUB_STEP_SUMMARY
        if [ $(find Resources/screenshots -name "*.png" | wc -l) -gt 10 ]; then
          echo "‚Ä¢ ... and more" >> $GITHUB_STEP_SUMMARY
        fi

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/warp-compliance.yml**
```
name: WARP Protocol Compliance

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  warp-compliance:
    name: WARP Workflow Compliance Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history needed for commit analysis
    
    - name: Set up Python for analysis
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Check BUGS.md updates for discovered issues
      run: |
        echo "Checking if BUGS.md is updated when issues are discovered..."
        
        # Check recent commits for bug-related keywords
        BUG_COMMITS=$(git log --since="7 days ago" --oneline --grep="fix\|bug\|issue\|error" || true)
        
        if [ ! -z "$BUG_COMMITS" ]; then
          echo "Found recent bug-related commits:"
          echo "$BUG_COMMITS"
          
          # Check if BUGS.md was updated in the same timeframe
          BUGS_UPDATES=$(git log --since="7 days ago" --oneline -- BUGS.md || true)
          
          if [ ! -z "$BUGS_UPDATES" ]; then
            echo "‚úÖ BUGS.md was updated recently alongside bug fixes"
          else
            echo "‚ö†Ô∏è Bug-related commits found but BUGS.md not updated"
            echo "WARP protocol requires documenting discovered issues in BUGS.md"
          fi
        else
          echo "‚úÖ No recent bug-related commits found"
        fi
    
    - name: Validate CHANGELOG.md entries for all changes
      run: |
        echo "Validating CHANGELOG.md entries for recent changes..."
        
        # Check if there are recent commits
        RECENT_COMMITS=$(git log --since="7 days ago" --oneline | wc -l)
        
        if [ $RECENT_COMMITS -gt 0 ]; then
          echo "Found $RECENT_COMMITS recent commit(s)"
          
          # Check if CHANGELOG.md was updated
          CHANGELOG_UPDATES=$(git log --since="7 days ago" --oneline -- CHANGELOG.md | wc -l)
          
          if [ $CHANGELOG_UPDATES -gt 0 ]; then
            echo "‚úÖ CHANGELOG.md was updated with recent changes"
            
            # Verify changelog follows proper format
            if grep -q "## \[" CHANGELOG.md && grep -q "### " CHANGELOG.md; then
              echo "‚úÖ CHANGELOG.md follows proper format"
            else
              echo "‚ö†Ô∏è CHANGELOG.md may not follow standard format"
            fi
          else
            echo "‚ö†Ô∏è Recent commits found but CHANGELOG.md not updated"
            echo "WARP protocol requires documenting all changes in CHANGELOG.md"
          fi
        else
          echo "‚úÖ No recent commits to check"
        fi
    
    - name: Check for visual evidence of UI/shader changes
      run: |
        echo "Checking for visual evidence of UI/shader changes..."
        
        # Check for recent commits that modify UI or shader files
        UI_SHADER_COMMITS=$(git log --since="7 days ago" --name-only --pretty=format: -- "*.swift" "*.metal" | grep -E "\.(swift|metal)$" | head -10 || true)
        
        if [ ! -z "$UI_SHADER_COMMITS" ]; then
          echo "Found recent UI/shader file changes:"
          echo "$UI_SHADER_COMMITS"
          
          # Check if screenshots were added/updated
          SCREENSHOT_UPDATES=$(git log --since="7 days ago" --name-only --pretty=format: -- "Resources/screenshots/" | grep -E "\.(png|jpg|jpeg)$" || true)
          
          if [ ! -z "$SCREENSHOT_UPDATES" ]; then
            echo "‚úÖ Screenshots were updated alongside UI/shader changes"
            echo "Updated screenshots:"
            echo "$SCREENSHOT_UPDATES"
          else
            echo "‚ö†Ô∏è UI/shader changes found but no screenshot evidence"
            echo "WARP protocol requires visual evidence for visual changes"
            
            # Check if screenshots directory exists at all
            if [ -d "Resources/screenshots" ]; then
              SCREENSHOT_COUNT=$(find Resources/screenshots -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" | wc -l)
              echo "Found $SCREENSHOT_COUNT existing screenshot(s)"
            else
              echo "‚ùå Resources/screenshots directory not found"
            fi
          fi
        else
          echo "‚úÖ No recent UI/shader changes detected"
        fi
    
    - name: Validate conventional commit message format
      run: |
        echo "Validating commit message format..."
        
        # Check recent commit messages for conventional format
        RECENT_COMMITS=$(git log --since="7 days ago" --pretty=format:"%s")
        
        if [ ! -z "$RECENT_COMMITS" ]; then
          echo "Analyzing recent commit messages:"
          
          CONVENTIONAL_COUNT=0
          TOTAL_COUNT=0
          
          while IFS= read -r commit_msg; do
            TOTAL_COUNT=$((TOTAL_COUNT + 1))
            
            # Check if follows conventional format (feat:, fix:, docs:, etc.)
            if [[ $commit_msg =~ ^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: ]]; then
              echo "‚úÖ '$commit_msg' follows conventional format"
              CONVENTIONAL_COUNT=$((CONVENTIONAL_COUNT + 1))
            else
              echo "‚ö†Ô∏è '$commit_msg' may not follow conventional format"
            fi
          done <<< "$RECENT_COMMITS"
          
          COMPLIANCE_RATE=$(( CONVENTIONAL_COUNT * 100 / TOTAL_COUNT ))
          echo "Conventional commit compliance: $COMPLIANCE_RATE% ($CONVENTIONAL_COUNT/$TOTAL_COUNT)"
          
          if [ $COMPLIANCE_RATE -ge 80 ]; then
            echo "‚úÖ Good commit message compliance"
          else
            echo "‚ö†Ô∏è Consider improving commit message format"
          fi
        else
          echo "‚úÖ No recent commits to check"
        fi
    
    - name: Verify WARP after-action requirements completion
      run: |
        echo "Verifying WARP after-action requirements..."
        
        # Create compliance checker script
        cat > warp_compliance_check.py << 'EOF'
        import os
        import json
        from datetime import datetime, timedelta
        import subprocess
        
        def check_warp_compliance():
            """Check WARP after-action requirements compliance"""
            
            compliance_score = 0
            max_score = 5
            issues = []
            
            # 1. Check BUGS.md exists and has recent updates
            if os.path.exists("BUGS.md"):
                print("‚úÖ BUGS.md exists")
                compliance_score += 1
            else:
                print("‚ùå BUGS.md missing")
                issues.append("BUGS.md file is missing")
            
            # 2. Check CHANGELOG.md exists and has proper format
            if os.path.exists("CHANGELOG.md"):
                with open("CHANGELOG.md", "r") as f:
                    content = f.read()
                    if "## [" in content and "### " in content:
                        print("‚úÖ CHANGELOG.md has proper format")
                        compliance_score += 1
                    else:
                        print("‚ö†Ô∏è CHANGELOG.md format could be improved")
                        issues.append("CHANGELOG.md should follow keep-a-changelog format")
            else:
                print("‚ùå CHANGELOG.md missing")
                issues.append("CHANGELOG.md file is missing")
            
            # 3. Check for screenshot evidence
            screenshots_dir = "Resources/screenshots"
            if os.path.exists(screenshots_dir):
                screenshot_count = len([f for f in os.listdir(screenshots_dir) 
                                     if f.endswith(('.png', '.jpg', '.jpeg'))])
                if screenshot_count > 0:
                    print(f"‚úÖ Found {screenshot_count} screenshot(s)")
                    compliance_score += 1
                else:
                    print("‚ö†Ô∏è No screenshots found")
                    issues.append("No visual evidence screenshots found")
            else:
                print("‚ùå Screenshots directory missing")
                issues.append("Resources/screenshots directory missing")
            
            # 4. Check WARP.md exists and contains required sections
            if os.path.exists("WARP.md"):
                with open("WARP.md", "r") as f:
                    content = f.read()
                    required_sections = [
                        "After-Action Requirements",
                        "Visual Evidence",
                        "CHANGELOG"
                    ]
                    
                    found_sections = sum(1 for section in required_sections if section in content)
                    if found_sections >= 2:
                        print(f"‚úÖ WARP.md contains {found_sections}/3 required sections")
                        compliance_score += 1
                    else:
                        print(f"‚ö†Ô∏è WARP.md missing some required sections ({found_sections}/3)")
                        issues.append("WARP.md should contain all required workflow sections")
            else:
                print("‚ùå WARP.md missing")
                issues.append("WARP.md workflow documentation missing")
            
            # 5. Check git repository is properly configured
            try:
                result = subprocess.run(['git', 'status'], capture_output=True, text=True)
                if result.returncode == 0:
                    print("‚úÖ Git repository is properly configured")
                    compliance_score += 1
                else:
                    print("‚ùå Git repository issues")
                    issues.append("Git repository not properly configured")
            except:
                print("‚ùå Git not available")
                issues.append("Git not available for version control")
            
            # Calculate compliance percentage
            compliance_percentage = (compliance_score / max_score) * 100
            
            print(f"\nüìä WARP Compliance Score: {compliance_score}/{max_score} ({compliance_percentage:.0f}%)")
            
            if issues:
                print("\n‚ö†Ô∏è Issues found:")
                for issue in issues:
                    print(f"  - {issue}")
            
            # Generate compliance report
            report = {
                "timestamp": datetime.now().isoformat(),
                "compliance_score": compliance_score,
                "max_score": max_score,
                "compliance_percentage": compliance_percentage,
                "issues": issues,
                "status": "PASS" if compliance_percentage >= 80 else "NEEDS_IMPROVEMENT"
            }
            
            with open("warp-compliance-report.json", "w") as f:
                json.dump(report, f, indent=2)
            
            return compliance_percentage >= 80
        
        if __name__ == "__main__":
            success = check_warp_compliance()
            if not success:
                print("\n‚ùå WARP compliance needs improvement")
                exit(1)
            else:
                print("\n‚úÖ WARP compliance requirements met")
        EOF
        
        python3 warp_compliance_check.py
    
    - name: Generate WARP compliance report
      run: |
        echo "Generating comprehensive WARP compliance report..."
        
        # Create detailed markdown report
        cat > warp-compliance-detailed-report.md << 'EOF'
        # WARP Protocol Compliance Report
        
        **Generated**: $(date)
        **Repository**: ${{ github.repository }}
        **Branch**: ${{ github.ref_name }}
        
        ## Compliance Summary
        
        This report validates adherence to the WARP (Workflow Agent Review Protocol) requirements:
        
        ### After-Action Requirements ‚úÖ
        - [x] BUGS.md maintained and updated
        - [x] CHANGELOG.md entries for all changes
        - [x] Visual evidence provided for visual changes
        - [x] Git operations with descriptive commits
        - [x] Testing validation completed
        
        ### Documentation Requirements ‚úÖ
        - [x] Technical documentation current
        - [x] API documentation maintained
        - [x] Examples functional
        - [x] Creative decisions documented
        
        ### Visual Testing Framework ‚úÖ
        - [x] Screenshot naming convention followed
        - [x] Visual artifacts stored correctly
        - [x] Regression testing framework ready
        - [x] Cross-resolution testing considered
        
        ## Recommendations
        
        1. **Maintain Visual Evidence**: Continue capturing screenshots for all UI/shader changes
        2. **Document Decisions**: Keep recording creative and technical decisions in documentation
        3. **Update Frequently**: Ensure BUGS.md and CHANGELOG.md are updated with each change
        4. **Test Coverage**: Expand visual regression testing as project grows
        
        ## Next Steps
        
        - Monitor compliance in future commits
        - Expand visual testing automation
        - Enhance documentation coverage
        - Improve commit message consistency
        EOF
        
        echo "‚úÖ WARP compliance report generated"
    
    - name: Upload WARP compliance artifacts
      uses: actions/upload-artifact@v4
      with:
        name: warp-compliance-report
        path: |
          warp-compliance-report.json
          warp-compliance-detailed-report.md
        retention-days: 30
    
    - name: WARP compliance summary
      run: |
        if [ -f "warp-compliance-report.json" ]; then
          COMPLIANCE_SCORE=$(python3 -c "import json; print(json.load(open('warp-compliance-report.json'))['compliance_percentage'])")
          STATUS=$(python3 -c "import json; print(json.load(open('warp-compliance-report.json'))['status'])")
          
          echo "## üéØ WARP Protocol Compliance" >> $GITHUB_STEP_SUMMARY
          echo "### Overall Score: ${COMPLIANCE_SCORE}%" >> $GITHUB_STEP_SUMMARY
          echo "### Status: $STATUS" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Requirements Checked" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ BUGS.md maintenance" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ CHANGELOG.md entries" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Visual evidence capture" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Commit message format" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Documentation compliance" >> $GITHUB_STEP_SUMMARY
          
          if [ "$STATUS" = "NEEDS_IMPROVEMENT" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **Action Required**: Review compliance report for improvement areas" >> $GITHUB_STEP_SUMMARY
          fi
        fi

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/test.yml**
```
name: Tests and Quality Assurance

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    name: Swift Tests and Quality Checks
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    # Using committed Package.swift; no need to generate one in CI
    
    - name: Create basic test structure
      run: |
        mkdir -p Tests/MetalShaderTests
        
        if [ ! -f "Tests/MetalShaderTests/ShaderTests.swift" ]; then
          echo "Creating basic shader tests..."
          cat > Tests/MetalShaderTests/ShaderTests.swift << 'EOF'
        import XCTest
        import Metal
        import MetalKit
        
        final class ShaderTests: XCTestCase {
            private var device: MTLDevice!
            
            override func setUp() {
                super.setUp()
                device = MTLCreateSystemDefaultDevice()
                XCTAssertNotNil(device, "Metal device should be available")
            }
            
            func testMetalDeviceAvailable() {
                XCTAssertNotNil(device, "Metal device should be available for testing")
            }
            
            func testShaderCompilation() {
                // Test basic shader compilation
                let shaderSource = """
                #include <metal_stdlib>
                using namespace metal;
                
                fragment float4 fragmentShader(VertexOut in [[stage_in]]) {
                    return float4(1.0, 0.0, 0.0, 1.0);
                }
                """
                
                do {
                    let library = try device.makeLibrary(source: shaderSource, options: nil)
                    let function = library.makeFunction(name: "fragmentShader")
                    XCTAssertNotNil(function, "Shader function should compile successfully")
                } catch {
                    XCTFail("Shader compilation failed: \(error)")
                }
            }
            
            func testShaderParameterBounds() {
                // Test parameter validation
                let testTime: Float = 0.0
                XCTAssertGreaterThanOrEqual(testTime, 0.0, "Time parameter should be non-negative")
                
                let testResolution = SIMD2<Float>(800.0, 600.0)
                XCTAssertGreaterThan(testResolution.x, 0, "Resolution width should be positive")
                XCTAssertGreaterThan(testResolution.y, 0, "Resolution height should be positive")
            }
        }
        
        struct VertexOut {
            var position: SIMD4<Float>
            var texCoord: SIMD2<Float>
        }
        EOF
          echo "‚úÖ Created basic shader tests"
        fi
    
- name: Run Swift tests (no coverage)
      run: |
        echo "Running Swift tests (baseline)..."
        if swift test --verbose 2>&1; then
          echo "‚úÖ Swift tests completed"
        else
          echo "‚ö†Ô∏è Swift tests reported failures or none found"
        fi

    - name: Run Swift tests with code coverage
      run: |
        echo "Running Swift tests with coverage..."
        set -e
        swift test --enable-code-coverage

    - name: Generate coverage report (llvm-cov)
      run: |
        set -eo pipefail
        echo "Generating coverage report..."
        PROF=$(ls -1 .build/debug/codecov/*.profdata 2>/dev/null | head -1 || true)
        if [ -z "$PROF" ]; then
          echo "‚ö†Ô∏è No .profdata found in .build/debug/codecov/"
        fi
        BINARIES=()
        if [ -x ".build/debug/MetalShaderStudio" ]; then BINARIES+=(".build/debug/MetalShaderStudio"); fi
        for x in .build/debug/*.xctest/Contents/MacOS/*; do
          if [ -x "$x" ]; then BINARIES+=("$x"); fi
        done
        if [ -n "$PROF" ] && [ ${#BINARIES[@]} -gt 0 ]; then
          echo "Using profdata: $PROF"
          echo "Binaries: ${BINARIES[*]}"
          xcrun llvm-cov export -format=lcov -instr-profile "$PROF" ${BINARIES[@]} > coverage.lcov || true
          xcrun llvm-cov report -instr-profile "$PROF" ${BINARIES[@]} > coverage.txt || true
          echo "‚úÖ Coverage artifacts generated"
        else
          echo "‚ö†Ô∏è Skipping coverage export - missing profdata or binaries"
        fi

    - name: Upload coverage artifacts
      uses: actions/upload-artifact@v4
      with:
        name: coverage
        path: |
          coverage.lcov
          coverage.txt
        retention-days: 7

    - name: Coverage summary
      run: |
        echo "## üìä Coverage Summary" >> $GITHUB_STEP_SUMMARY
        if [ -f coverage.txt ]; then
          echo "### llvm-cov Report" >> $GITHUB_STEP_SUMMARY
          TOTAL_LINE=$(grep -E "^TOTAL|TOTAL:" coverage.txt | head -1 || true)
          if [ -n "$TOTAL_LINE" ]; then
            echo "- $TOTAL_LINE" >> $GITHUB_STEP_SUMMARY
          else
            # Fallback: show last lines
            tail -n 5 coverage.txt >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Artifacts: coverage.lcov, coverage.txt" >> $GITHUB_STEP_SUMMARY
        else
          echo "- Coverage report not generated (no profdata/binaries)." >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Validate Metal shader files compilation
      run: |
        echo "Validating all Metal shader files..."
        SHADER_ERRORS=0
        SHADER_COUNT=0
        
        # Test shaders in the shaders directory
        if [ -d "shaders" ]; then
          for shader_file in shaders/*.metal; do
            if [ -f "$shader_file" ]; then
              SHADER_COUNT=$((SHADER_COUNT + 1))
              echo "Testing shader: $shader_file"
              
              if xcrun -sdk macosx metal -c "$shader_file" -o /tmp/$(basename "$shader_file" .metal).air 2>/dev/null; then
                echo "‚úÖ $(basename "$shader_file") compiles successfully"
              else
                echo "‚ùå $(basename "$shader_file") compilation failed"
                SHADER_ERRORS=$((SHADER_ERRORS + 1))
              fi
            fi
          done
        fi
        
        # Test communication shader
        if [ -f "Resources/communication/current_shader.metal" ]; then
          SHADER_COUNT=$((SHADER_COUNT + 1))
          echo "Testing current shader: Resources/communication/current_shader.metal"
          
          if xcrun -sdk macosx metal -c "Resources/communication/current_shader.metal" -o /tmp/current_shader.air 2>/dev/null; then
            echo "‚úÖ current_shader.metal compiles successfully"
          else
            echo "‚ùå current_shader.metal compilation failed"
            SHADER_ERRORS=$((SHADER_ERRORS + 1))
          fi
        fi
        
        echo "Shader validation summary:"
        echo "- Total shaders tested: $SHADER_COUNT"
        echo "- Compilation errors: $SHADER_ERRORS"
        echo "- Success rate: $(( (SHADER_COUNT - SHADER_ERRORS) * 100 / SHADER_COUNT ))%"
        
        if [ $SHADER_ERRORS -gt 0 ]; then
          echo "‚ùå $SHADER_ERRORS shader(s) failed compilation"
          exit 1
        else
          echo "‚úÖ All Metal shaders compile successfully"
        fi
    
    - name: Test shader parameter combinations
      run: |
        echo "Testing shader parameter combinations..."
        
        # Create a test script to validate parameter combinations
        cat > test_parameters.py << 'EOF'
        import math
        
        def test_parameter_combinations():
            """Test various parameter combinations for shader stability"""
            
            # Time parameter tests
            time_values = [0.0, 1.0, 10.0, 100.0, 1000.0]
            for time in time_values:
                assert time >= 0, f"Time should be non-negative: {time}"
                print(f"‚úÖ Time parameter {time} is valid")
            
            # Resolution tests
            resolutions = [(800, 600), (1920, 1080), (2560, 1440), (512, 512)]
            for width, height in resolutions:
                assert width > 0 and height > 0, f"Resolution should be positive: {width}x{height}"
                aspect_ratio = width / height
                assert 0.1 <= aspect_ratio <= 10.0, f"Aspect ratio should be reasonable: {aspect_ratio}"
                print(f"‚úÖ Resolution {width}x{height} is valid")
            
            # Mouse coordinate tests (normalized 0-1)
            mouse_coords = [(0.0, 0.0), (0.5, 0.5), (1.0, 1.0), (0.25, 0.75)]
            for x, y in mouse_coords:
                assert 0.0 <= x <= 1.0, f"Mouse X should be 0-1: {x}"
                assert 0.0 <= y <= 1.0, f"Mouse Y should be 0-1: {y}"
                print(f"‚úÖ Mouse coordinates ({x}, {y}) are valid")
            
            print("‚úÖ All parameter combination tests passed")
        
        if __name__ == "__main__":
            test_parameter_combinations()
        EOF
        
        python3 test_parameters.py
    
    - name: Check for memory leaks and performance issues
      run: |
        echo "Checking for potential memory leaks and performance issues..."
        
        # Analyze Swift code for common performance pitfalls
        if grep -n "strong self" *.swift; then
          echo "‚ö†Ô∏è Found potential retain cycles - review strong references"
        else
          echo "‚úÖ No obvious retain cycle patterns found"
        fi
        
        if grep -n "Timer.scheduledTimer" *.swift; then
          echo "‚úÖ Found Timer usage - ensure proper cleanup"
        else
          echo "‚úÖ No Timer usage detected"
        fi
        
        # Check for proper Metal resource cleanup
        if grep -n "MTLDevice\|MTLCommandQueue\|MTLBuffer" *.swift; then
          echo "‚úÖ Found Metal resource usage - ensure proper lifecycle management"
        fi
        
        echo "‚úÖ Performance check completed"
    
    - name: Generate test coverage report (mock)
      run: |
        echo "Generating test coverage report..."
        
        # For now, create a mock coverage report
        # In a real implementation, we would use swift test --enable-code-coverage
        cat > test-coverage-report.md << 'EOF'
        # Test Coverage Report
        
        ## Summary
        - **Lines Covered**: 85% (estimated)
        - **Functions Covered**: 90% (estimated)  
        - **Branches Covered**: 80% (estimated)
        
        ## Files Tested
        - ShaderPlayground.swift: Core functionality
        - Metal shader files: Compilation validation
        - Parameter validation: Boundary testing
        
        ## Areas for Improvement
        - Add more unit tests for shader parameter combinations
        - Implement integration tests for Metal rendering pipeline
        - Add performance benchmarks for shader compilation
        
        ## Recommendations
        - Increase test coverage for error handling paths
        - Add visual regression tests for shader outputs
        - Implement automated performance testing
        EOF
        
        echo "‚úÖ Test coverage report generated"
    
    - name: Validate project structure integrity
      run: |
        echo "Validating project structure integrity..."
        
        # Check for required files
        REQUIRED_FILES=(
          "ShaderPlayground.swift"
          "Resources/communication"
          "WARP.md"
          "CHANGELOG.md"
          "BUGS.md"
        )
        
        MISSING_FILES=0
        for file in "${REQUIRED_FILES[@]}"; do
          if [ -e "$file" ]; then
            echo "‚úÖ $file exists"
          else
            echo "‚ùå $file is missing"
            MISSING_FILES=$((MISSING_FILES + 1))
          fi
        done
        
        if [ $MISSING_FILES -eq 0 ]; then
          echo "‚úÖ All required project files are present"
        else
          echo "‚ùå $MISSING_FILES required file(s) missing"
          exit 1
        fi
        
        # Check directory structure
        if [ -d "Resources/screenshots" ]; then
          echo "‚úÖ Screenshot directory exists"
        else
          echo "‚ö†Ô∏è Screenshot directory missing - will be created"
          mkdir -p Resources/screenshots
        fi
    
    - name: Upload test artifacts
      uses: actions/upload-artifact@v4
      with:
        name: test-reports
        path: |
          test-coverage-report.md
          **/*.air
        retention-days: 7
    
    - name: Test summary
      run: |
        echo "## üß™ Test Summary" >> $GITHUB_STEP_SUMMARY
        echo "### Status" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Swift tests executed" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Metal shader compilation validated" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Parameter combinations tested" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Performance checks completed" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Project structure validated" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Metrics" >> $GITHUB_STEP_SUMMARY
        SHADER_COUNT=$(find . -name "*.metal" | wc -l)
        echo "- üìä Metal shaders tested: $SHADER_COUNT" >> $GITHUB_STEP_SUMMARY
        echo "- üìà Estimated test coverage: 85%" >> $GITHUB_STEP_SUMMARY
        echo "- üéØ All quality gates passed" >> $GITHUB_STEP_SUMMARY

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/swift-build.yml**
```
name: Swift/Metal Build and Validation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  swift-metal-build:
    name: Swift/Metal Compilation
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Cache Swift dependencies
      uses: actions/cache@v4
      with:
        path: |
          .build
          .swiftpm
          ~/Library/Caches/org.swift.swiftpm
        key: ${{ runner.os }}-swift-${{ hashFiles('Package.swift', 'Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-swift-
    
    - name: Check Swift version
      run: swift --version
    
    - name: Verify Metal framework availability
      run: |
        xcrun -sdk macosx metal --version
        echo "Metal compiler available"
    
    - name: Build with SwiftPM
      run: |
        echo "Building with Swift Package Manager..."
        swift build --configuration debug
        echo "‚úÖ swift build completed"
    
    - name: Validate Metal shader files
      run: |
        echo "Validating Metal shader files..."
        SHADER_ERRORS=0
        
        for shader in shaders/*.metal Resources/communication/*.metal; do
          if [ -f "$shader" ]; then
            echo "Validating $shader..."
            if xcrun -sdk macosx metal -c "$shader" -o /tmp/$(basename "$shader" .metal).air; then
              echo "‚úÖ $shader compiled successfully"
            else
              echo "‚ùå $shader failed to compile"
              SHADER_ERRORS=$((SHADER_ERRORS + 1))
            fi
          fi
        done
        
        if [ $SHADER_ERRORS -gt 0 ]; then
          echo "‚ùå $SHADER_ERRORS shader(s) failed to compile"
          exit 1
        else
          echo "‚úÖ All Metal shader files compiled successfully"
        fi
    
    - name: Test built executable exists
      run: |
        echo "Checking built executable..."
        if [ -x ".build/debug/MetalShaderStudio" ]; then
          echo "‚úÖ .build/debug/MetalShaderStudio exists"
          file .build/debug/MetalShaderStudio
        else
          echo "‚ùå .build/debug/MetalShaderStudio not found"
          exit 1
        fi
    
    - name: Archive build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: metal-shader-studio-build
        path: |
          .build/debug/MetalShaderStudio
          **/*.air
        retention-days: 7
    
    - name: Build summary
      run: |
        echo "## üèóÔ∏è Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Swift compilation successful" >> $GITHUB_STEP_SUMMARY  
        echo "- ‚úÖ Metal shaders validated" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ MetalShaderStudio executable created" >> $GITHUB_STEP_SUMMARY
        echo "- üì¶ Build artifacts uploaded" >> $GITHUB_STEP_SUMMARY

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/ui-smoke.yml**
```
name: UI Smoke (tab + status)

on:
  pull_request:
    paths:
      - 'ShaderPlayground.swift'
      - 'AppShellView.swift'
      - 'HistoryTabView.swift'
      - 'SessionRecorder.swift'
      - 'scripts/screenshot_app.sh'
      - 'scripts/set_tab.sh'
      - 'scripts/ci/ui_smoke.sh'

jobs:
  ui-smoke:
    runs-on: macos-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Run UI smoke
        run: |
          bash scripts/ci/ui_smoke.sh

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/epic-sync.yml**
```
name: EPIC Progress Sync

on:
  push:
    branches: ["**"]
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]
  workflow_dispatch:

# Explicit permissions so the workflow can comment on issues
permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  epic-sync:
    name: Post progress to EPIC issues
    runs-on: ubuntu-latest
    if: >-
      ${{ github.event_name == 'push' ||
          (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false) ||
          github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Ensure dependencies (jq, gh)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      - name: Authenticate gh CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh auth status || echo "gh will use GH_TOKEN from env"

      - name: Run EPIC sync script
        env:
          # Used by scripts/post_commit_sync.sh to link to PR if available
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          bash scripts/post_commit_sync.sh

      - name: Summary
        run: |
          echo "## üß≠ EPIC Progress Sync" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ EPIC sync job executed" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ Script: scripts/post_commit_sync.sh" >> $GITHUB_STEP_SUMMARY
          echo "- üîê Auth: GITHUB_TOKEN (issues:write)" >> $GITHUB_STEP_SUMMARY

```

**/Users/erichowens/coding/metal-shader-mcp/.github/workflows/documentation.yml**
```
name: Documentation Validation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  validate-docs:
    name: Documentation Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install markdown tools
      run: |
        npm install -g markdownlint-cli
        npm install -g markdown-link-check
    
    - name: Validate markdown syntax
      run: |
        echo "Validating markdown syntax..."
        markdownlint --config ./.github/markdownlint.json *.md || true
        echo "‚úÖ Markdown syntax validation complete"
    
    - name: Check for broken links
      run: |
        echo "Checking for broken internal links..."
        find . -name "*.md" -not -path "./node_modules/*" -not -path "./.git/*" | \
        xargs -I {} markdown-link-check {} --config ./.github/markdown-link-check.json || true
        echo "‚úÖ Link validation complete"
    
    - name: Validate CHANGELOG.md format
      run: |
        echo "Validating CHANGELOG.md format..."
        if [ -f "CHANGELOG.md" ]; then
          # Check for standard changelog headers
          if grep -q "## \[" CHANGELOG.md && grep -q "### " CHANGELOG.md; then
            echo "‚úÖ CHANGELOG.md follows keep-a-changelog format"
          else
            echo "‚ö†Ô∏è CHANGELOG.md may not follow standard format"
          fi
          
          # Check for recent entries (entries from last 30 days)
          if git log --since="30 days ago" --oneline | head -1 > /dev/null 2>&1; then
            echo "Recent commits found, checking for corresponding changelog entries..."
          fi
        else
          echo "‚ùå CHANGELOG.md not found"
          exit 1
        fi
    
    - name: Validate BUGS.md structure
      run: |
        echo "Validating BUGS.md structure..."
        if [ -f "BUGS.md" ]; then
          # Check for required sections
          if grep -q "# " BUGS.md; then
            echo "‚úÖ BUGS.md has proper structure"
          else
            echo "‚ö†Ô∏è BUGS.md may be missing headers"
          fi
        else
          echo "‚ùå BUGS.md not found"
          exit 1
        fi
    
    - name: Validate WARP.md workflow requirements
      run: |
        echo "Validating WARP.md workflow documentation..."
        if [ -f "WARP.md" ]; then
          # Check for key WARP workflow elements
          WARP_CHECKS=0
          if grep -q "After-Action Requirements" WARP.md; then
            echo "‚úÖ After-Action Requirements documented"
            WARP_CHECKS=$((WARP_CHECKS + 1))
          fi
          
          if grep -q "Visual Evidence" WARP.md; then
            echo "‚úÖ Visual Evidence requirements documented"
            WARP_CHECKS=$((WARP_CHECKS + 1))
          fi
          
          if grep -q "CHANGELOG" WARP.md; then
            echo "‚úÖ Changelog requirements documented"
            WARP_CHECKS=$((WARP_CHECKS + 1))
          fi
          
          if [ $WARP_CHECKS -ge 3 ]; then
            echo "‚úÖ WARP.md contains required workflow documentation"
          else
            echo "‚ö†Ô∏è WARP.md may be missing some workflow requirements"
          fi
        else
          echo "‚ùå WARP.md not found"
          exit 1
        fi
    
    - name: Check for required screenshot evidence
      run: |
        echo "Checking for screenshot evidence in Resources/screenshots/..."
        if [ -d "Resources/screenshots" ]; then
          SCREENSHOT_COUNT=$(find Resources/screenshots -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" | wc -l)
          if [ $SCREENSHOT_COUNT -gt 0 ]; then
            echo "‚úÖ Found $SCREENSHOT_COUNT screenshot(s) in Resources/screenshots/"
            ls -la Resources/screenshots/
          else
            echo "‚ö†Ô∏è No screenshots found in Resources/screenshots/"
          fi
        else
          echo "‚ö†Ô∏è Resources/screenshots/ directory not found"
          mkdir -p Resources/screenshots
          echo "üìÅ Created Resources/screenshots/ directory"
        fi
    
    - name: Validate project documentation completeness
      run: |
        echo "Checking for essential documentation files..."
        REQUIRED_DOCS=("README.md" "SETUP.md" "DESIGN.md" "VISUAL_TESTING.md")
        MISSING_DOCS=0
        
        for doc in "${REQUIRED_DOCS[@]}"; do
          if [ -f "$doc" ]; then
            echo "‚úÖ $doc found"
          else
            echo "‚ùå $doc missing"
            MISSING_DOCS=$((MISSING_DOCS + 1))
          fi
        done
        
        if [ $MISSING_DOCS -eq 0 ]; then
          echo "‚úÖ All essential documentation files present"
        else
          echo "‚ö†Ô∏è $MISSING_DOCS essential documentation file(s) missing"
        fi
    
    - name: Generate documentation report
      run: |
        echo "## üìö Documentation Validation Report" >> $GITHUB_STEP_SUMMARY
        echo "### Files Checked" >> $GITHUB_STEP_SUMMARY
        find . -name "*.md" -not -path "./node_modules/*" -not -path "./.git/*" | \
        sed 's|^\./||' | sort | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Status" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Markdown syntax validated" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Links checked" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ WARP.md requirements verified" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Essential documentation verified" >> $GITHUB_STEP_SUMMARY

```





**Grep Results:**

- **/Users/erichowens/coding/metal-shader-mcp/ShaderPlayground.swift**
- **/Users/erichowens/coding/metal-shader-mcp/SessionRecorder.swift**
- **/Users/erichowens/coding/metal-shader-mcp/src/simple-mcp.ts**




**Files Read:**

**/Users/erichowens/coding/metal-shader-mcp/ShaderPlayground.swift**
```
import SwiftUI
import MetalKit
import Metal
import UniformTypeIdentifiers
import CryptoKit
import AppKit

@main
struct ShaderPlaygroundApp: App {
    @StateObject var appState = AppState()

    var body: some Scene {
        WindowGroup("Claude's Shader Playground") {
            AppShellView(initialTab: Self.initialTabFromArgs())
                .environmentObject(appState)
                .frame(minWidth: 1000, minHeight: 700)
        }
    }

    private static func initialTabFromArgs() -> AppTab {
        let args = CommandLine.arguments
        func map(_ s: String) -> AppTab? {
            switch s.lowercased() {
            case "repl": return .repl
            case "library": return .library
            case "projects": return .projects
            case "tools", "mcp", "mcp-tools": return .tools
            case "history", "sessions": return .history
            default: return nil
            }
        }
        if let i = args.firstIndex(of: "--tab"), i+1 < args.count, let t = map(args[i+1]) { return t }
        if let i = args.firstIndex(of: "-t"), i+1 < args.count, let t = map(args[i+1]) { return t }
        return .repl
    }
}

struct ContentView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var renderer = MetalShaderRenderer()
    @StateObject private var session = SessionRecorder()
@State private var shaderCode = defaultShader
    @State private var shaderMeta = ShaderMetadata.from(code: defaultShader, path: nil)
    
    let communicationDir = "Resources/communication"
    let shaderStateFile = "Resources/communication/current_shader.metal"
    let commandFile = "Resources/communication/commands.json"
    let statusFile = "Resources/communication/status.json"
    let errorsFile = "Resources/communication/compilation_errors.json"
    
    var body: some View {
        HStack(spacing: 0) {
            // Left: Code Editor
            VStack {
                Text("Shader Code")
                    .font(.headline)
                    .padding()
                
TextEditor(text: $shaderCode)
                    .font(.system(.body, design: .monospaced))
                    .onChange(of: shaderCode) { newCode in
                        renderer.updateShader(newCode)
                        shaderMeta = ShaderMetadata.from(code: newCode, path: shaderStateFile)
                        writeCurrentShaderMeta()
                    }
                
HStack(spacing: 12) {
                    Button("Compile & Update") {
renderer.updateShader(shaderCode)
                        shaderMeta = ShaderMetadata.from(code: shaderCode, path: shaderStateFile)
                        writeCurrentShaderMeta()
                    }
                    Button("Save As‚Ä¶") {
                        saveAsShaderDialog()
                    }
                }
                .padding(.horizontal)
                .padding(.bottom)
            }
            .frame(maxWidth: .infinity)
            
            Divider()
            
            // Right: Metal Preview
VStack {
                Text("Live Preview")
                    .font(.headline)
                    .padding(.top)
                // Shader name and description (from docstring)
                VStack(alignment: .leading, spacing: 4) {
                    Text(shaderMeta.name.isEmpty ? "Untitled Shader" : shaderMeta.name)
                        .font(.title3).bold()
                        .frame(maxWidth: .infinity, alignment: .leading)
                    if !shaderMeta.description.isEmpty {
                        Text(shaderMeta.description)
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }
                }
                .padding(.horizontal)
                .padding(.bottom, 4)
                
                MetalView(renderer: renderer)
                    .aspectRatio(1.0, contentMode: .fit)
                    .padding()
                
                HStack {
                    Button("Export Frame") {
                        renderer.saveScreenshot()
                    }
                    
                    Button("Export Sequence") {
                        renderer.exportFrameSequence(description: "animation_sequence")
                    }
                    
                    Text("FPS: \(Int(renderer.fps))")
                        .font(.system(.body, design: .monospaced))
                }
                .padding()
            }
            .frame(maxWidth: .infinity)
        }
        .onAppear {
            setupCommunication()
            startMonitoringCommands()
        }
    }
    
    // MARK: - Communication Functions
private func setupCommunication() {
        // Ensure metadata is initialized
        shaderMeta = ShaderMetadata.from(code: shaderCode, path: shaderStateFile)
        writeCurrentShaderMeta()
        // Create communication directory
        try? FileManager.default.createDirectory(atPath: communicationDir, withIntermediateDirectories: true)
        
        // Initialize shader state file
        try? shaderCode.write(toFile: shaderStateFile, atomically: true, encoding: .utf8)
        
        // Initialize status file
        let status = ["status": "ready", "timestamp": Date().timeIntervalSince1970] as [String: Any]
        if let statusData = try? JSONSerialization.data(withJSONObject: status) {
            try? statusData.write(to: URL(fileURLWithPath: statusFile))
        }
    }
    
private func startMonitoringCommands() {
        // Ensure communication dir exists
        try? FileManager.default.createDirectory(atPath: communicationDir, withIntermediateDirectories: true)
        Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            checkForCommands()
        }
    }
    
    private func checkForCommands() {
        guard FileManager.default.fileExists(atPath: commandFile) else { return }
        
        do {
            let commandData = try Data(contentsOf: URL(fileURLWithPath: commandFile))
            let command = try JSONSerialization.jsonObject(with: commandData) as? [String: Any]
            
            if let action = command?["action"] as? String {
                switch action {
case "set_shader":
                    if let newCode = command?["shader_code"] as? String {
                        let desc = command?["description"] as? String
                        let noSnapshot = (command?["no_snapshot"] as? Bool) ?? false
                        DispatchQueue.main.async {
                            self.shaderCode = newCode
                            self.renderer.updateShader(newCode)
                            if !noSnapshot {
                                self.session.recordSnapshot(code: newCode, renderer: self.renderer, label: desc)
                            }
                        }
                    }
case "get_shader_meta":
                    // Write current shader meta (already maintained)
                    self.writeCurrentShaderMeta()

                case "set_shader_with_meta":
                    let newCode = command?["shader_code"] as? String
                    let name = command?["name"] as? String
                    let desc = command?["description"] as? String
                    let path = command?["path"] as? String
                    let save = (command?["save"] as? Bool) ?? false
                    let noSnapshot = (command?["no_snapshot"] as? Bool) ?? false
                    DispatchQueue.main.async {
                        if let newCode = newCode {
                            self.shaderCode = newCode
                            self.renderer.updateShader(newCode)
                        }
                        // Update metadata
                        var meta = ShaderMetadata.from(code: self.shaderCode, path: self.shaderStateFile)
                        if let name = name { meta.name = name }
                        if let desc = desc { meta.description = desc }
                        if let path = path, !path.isEmpty { meta.path = path }
                        self.shaderMeta = meta
                        self.writeCurrentShaderMeta()
                        // Save to path if requested
                        if save, let p = meta.path, !p.isEmpty {
                            Self.writeTextSafely(self.shaderCode, toPath: p)
                        }
                        if !noSnapshot {
                            self.session.recordSnapshot(code: self.shaderCode, renderer: self.renderer, label: "set_shader_with_meta")
                        }
                    }

                case "list_library_entries":
                    self.writeLibraryIndex()

                case "save_snapshot":
                    let desc = command?["description"] as? String ?? "snapshot"
                    DispatchQueue.main.async {
                        self.session.recordSnapshot(code: self.shaderCode, renderer: self.renderer, label: desc)
                    }
                case "export_frame":
                    let description = command?["description"] as? String ?? "mcp_export"
                    let time = command?["time"] as? Float
                    renderer.exportFrame(description: description, time: time)
                    
                case "set_tab":
                    if let tabName = command?["tab"] as? String {
                        DispatchQueue.main.async {
                            let lower = tabName.lowercased()
                            if lower == "repl" { self.appState.selectedTab = .repl }
                            else if lower == "library" { self.appState.selectedTab = .library }
                            else if lower == "projects" { self.appState.selectedTab = .projects }
                            else if lower == "tools" || lower == "mcp" || lower == "mcp-tools" { self.appState.selectedTab = .tools }
                            else if lower == "history" || lower == "sessions" { self.appState.selectedTab = .history }
                        }
                    }
                case "export_sequence":
                    let description = command?["description"] as? String ?? "mcp_sequence"
                    let duration = command?["duration"] as? Float ?? 5.0
                    let fps = command?["fps"] as? Int ?? 30
                    renderer.exportFrameSequence(description: description, duration: duration, fps: fps)
                    
                default:
                    break
                }
                
                // Update status
                updateStatus(action: action, success: true)
                
                // Remove command file
                try? FileManager.default.removeItem(atPath: commandFile)
            }
        } catch {
            updateStatus(action: "unknown", success: false, error: error.localizedDescription)
            try? FileManager.default.removeItem(atPath: commandFile)
        }
    }
    
    private func updateStatus(action: String, success: Bool, error: String? = nil) {
        let status = [
            "last_action": action,
            "success": success,
            "timestamp": Date().timeIntervalSince1970,
            "error": error as Any
        ] as [String: Any]
        
        if let statusData = try? JSONSerialization.data(withJSONObject: status) {
            try? statusData.write(to: URL(fileURLWithPath: statusFile))
        }
        
        // Also update shader state file
        try? shaderCode.write(toFile: shaderStateFile, atomically: true, encoding: .utf8)
    }
}

// MARK: - Shader Metadata
struct ShaderMetadata: Codable {
    var name: String
    var description: String
    var path: String?

    static func from(code: String, path: String?) -> ShaderMetadata {
        // Extract the first block comment /** ... */ as docstring
        // Fallbacks if not present
        let trimmed = code.trimmingCharacters(in: .whitespacesAndNewlines)
        var title = ""
        var desc = ""
        if let startRange = trimmed.range(of: "/**"), let endRange = trimmed.range(of: "*/", range: startRange.upperBound..<trimmed.endIndex) {
            let doc = String(trimmed[startRange.upperBound..<endRange.lowerBound])
            // Split into lines, strip leading * and spaces
            let lines = doc.split(separator: "\n").map { line -> String in
                var s = String(line)
                if s.trimmingCharacters(in: .whitespaces).hasPrefix("*") {
                    s = s.replacingOccurrences(of: "*", with: "", options: [], range: s.range(of: "*"))
                }
                return s.trimmingCharacters(in: .whitespaces)
            }
            // First non-empty line as title, subsequent non-empty lines until blank as description (joined)
            var i = 0
            while i < lines.count && lines[i].isEmpty { i += 1 }
            if i < lines.count { title = lines[i]; i += 1 }
            var descLines: [String] = []
            while i < lines.count {
                let l = lines[i]
                if l.isEmpty { break }
                descLines.append(l)
                i += 1
            }
            desc = descLines.joined(separator: " ")
        }
        if title.isEmpty { title = "Untitled Shader" }
        return ShaderMetadata(name: title, description: desc, path: path)
    }
}

extension ContentView {
    func saveAsShaderDialog() {
        let panel = NSSavePanel()
        panel.allowedFileTypes = ["metal"]
        panel.canCreateDirectories = true
        panel.title = "Save Shader As"
        // Default directory: ./shaders
        let shadersDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath).appendingPathComponent("shaders")
        try? FileManager.default.createDirectory(at: shadersDir, withIntermediateDirectories: true)
        panel.directoryURL = shadersDir
        panel.nameFieldStringValue = (shaderMeta.name.isEmpty ? "Untitled Shader" : shaderMeta.name).replacingOccurrences(of: " ", with: "_").lowercased() + ".metal"
        if panel.runModal() == .OK, let url = panel.url {
            let path = url.path
            Self.writeTextSafely(shaderCode, toPath: path)
            // Update meta path and rewrite meta
            shaderMeta.path = path
            writeCurrentShaderMeta()
        }
    }

    static func writeTextSafely(_ text: String, toPath path: String) {
        let dir = (path as NSString).deletingLastPathComponent
        try? FileManager.default.createDirectory(atPath: dir, withIntermediateDirectories: true)
        // If file exists, replace
        if FileManager.default.fileExists(atPath: path) {
            _ = try? FileManager.default.removeItem(atPath: path)
        }
        try? text.write(toFile: path, atomically: true, encoding: .utf8)
    }

    func writeLibraryIndex() {
        let shadersDir = "shaders"
        var entries: [[String: Any]] = []
        if let files = try? FileManager.default.contentsOfDirectory(atPath: shadersDir) {
            for fn in files where fn.hasSuffix(".metal") {
                let full = shadersDir + "/" + fn
                if let code = try? String(contentsOfFile: full) {
                    let meta = ShaderMetadata.from(code: code, path: full)
                    entries.append([
                        "name": meta.name,
                        "description": meta.description,
                        "path": full
                    ])
                }
            }
        }
        let obj: [String: Any] = [
            "entries": entries,
            "count": entries.count,
            "timestamp": Date().timeIntervalSince1970
        ]
        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
            try? data.write(to: URL(fileURLWithPath: communicationDir + "/library_index.json"))
        }
    }
    func writeCurrentShaderMeta() {
        let meta = shaderMeta
        let obj: [String: Any] = [
            "name": meta.name,
            "description": meta.description,
            "path": meta.path ?? "",
            "timestamp": Date().timeIntervalSince1970
        ]
        if let data = try? JSONSerialization.data(withJSONObject: obj, options: [.prettyPrinted]) {
            try? FileManager.default.createDirectory(atPath: communicationDir, withIntermediateDirectories: true)
            try? data.write(to: URL(fileURLWithPath: communicationDir + "/shader_meta.json"))
        }
    }
}

// MARK: - Metal Renderer
class MetalShaderRenderer: ObservableObject {
    private let device: MTLDevice
    private let commandQueue: MTLCommandQueue
    @Published var fps: Double = 0
    private var pipelineState: MTLRenderPipelineState?
    private var startTime = CACurrentMediaTime()
    
    // Uniform override support (from Resources/communication/uniforms.json)
    private let uniformsFile = "Resources/communication/uniforms.json"
    private var overrideTime: Float?
    private var overrideResolution: SIMD2<Float>?
    private var overrideMouse: SIMD2<Float>?
    
    init() {
        guard let device = MTLCreateSystemDefaultDevice(),
              let commandQueue = device.makeCommandQueue() else {
            fatalError("Metal is not supported")
        }
        
        self.device = device
        self.commandQueue = commandQueue
        
        // Compile default shader
        updateShader(defaultShader)
        
        // Start polling for uniform overrides
        Timer.scheduledTimer(withTimeInterval: 0.3, repeats: true) { [weak self] _ in
            self?.loadUniformOverrides()
        }
    }
    
    func updateShader(_ source: String) {
        do {
            let library = try device.makeLibrary(source: source, options: nil)
            guard let fragmentFunction = library.makeFunction(name: "fragmentShader") else {
                print("Could not find fragmentShader function")
                saveCompilationErrors(["Could not find fragmentShader function in shader code"], warnings: [])
                return
            }
            
            let pipelineDescriptor = MTLRenderPipelineDescriptor()
            pipelineDescriptor.vertexFunction = createVertexFunction()
            pipelineDescriptor.fragmentFunction = fragmentFunction
            pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm
            
            pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
            print("‚úÖ Shader compiled successfully")
            saveCompilationErrors([], warnings: []) // Clear errors on successful compile
            
        } catch {
            print("‚ùå Shader compilation failed: \(error)")
            let errorMessage = parseMetalError(error.localizedDescription)
            saveCompilationErrors([errorMessage], warnings: [])
        }
    }
    
    private func parseMetalError(_ errorString: String) -> String {
        // Parse Metal compiler errors to extract useful information
        if errorString.contains("program_source") {
            let lines = errorString.components(separatedBy: .newlines)
            for line in lines {
                if line.contains(":") && (line.contains("error:") || line.contains("warning:")) {
                    return line.trimmingCharacters(in: .whitespaces)
                }
            }
        }
        return errorString
    }
    
    private func saveCompilationErrors(_ errors: [String], warnings: [String]) {
        let errorsData = [
            "errors": errors.map { error in
                [
                    "message": error,
                    "line": extractLineNumber(from: error) ?? 0,
                    "suggestion": generateSuggestion(for: error)
                ]
            },
            "warnings": warnings.map { warning in
                [
                    "message": warning,
                    "line": extractLineNumber(from: warning) ?? 0
                ]
            },
            "timestamp": Date().timeIntervalSince1970
        ] as [String : Any]
        
        let errorsFile = "Resources/communication/compilation_errors.json"
        if let errorsJsonData = try? JSONSerialization.data(withJSONObject: errorsData, options: .prettyPrinted) {
            try? errorsJsonData.write(to: URL(fileURLWithPath: errorsFile))
        }
    }
    
    private func extractLineNumber(from error: String) -> Int? {
        // Extract line number from Metal error messages
        let pattern = ":(\\d+):"
        let regex = try? NSRegularExpression(pattern: pattern)
        let range = NSRange(location: 0, length: error.utf16.count)
        
        if let match = regex?.firstMatch(in: error, options: [], range: range) {
            let lineRange = Range(match.range(at: 1), in: error)
            if let lineRange = lineRange {
                return Int(String(error[lineRange]))
            }
        }
        return nil
    }
    
    private func generateSuggestion(for error: String) -> String {
        let errorLower = error.lowercased()
        
        if errorLower.contains("undeclared identifier") {
            return "Check variable and function names for typos. Make sure all variables are declared."
        } else if errorLower.contains("expected") {
            return "Check syntax - missing semicolons, brackets, or parentheses."
        } else if errorLower.contains("use of undeclared type") {
            return "Make sure all Metal types are spelled correctly (float, float2, float3, float4, etc.)."
        } else if errorLower.contains("fragmentshader") {
            return "Make sure your fragment function is named 'fragmentShader' and has the correct signature."
        }
        return "Review Metal shading language documentation for correct syntax."
    }
    
    // Load uniform overrides from file if present
    private func loadUniformOverrides() {
        guard FileManager.default.fileExists(atPath: uniformsFile) else { return }
        do {
            let data = try Data(contentsOf: URL(fileURLWithPath: uniformsFile))
            let obj = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            let uniforms = obj?["uniforms"] as? [String: Any]
            
            if let t = uniforms?["time"] as? NSNumber {
                overrideTime = t.floatValue
            } else if uniforms?.keys.contains("time") == true {
                // Explicitly allow clearing the override by setting null
                overrideTime = nil
            }
            
            if let res = uniforms?["resolution"] as? [NSNumber], res.count >= 2 {
                overrideResolution = SIMD2<Float>(res[0].floatValue, res[1].floatValue)
            } else if uniforms?.keys.contains("resolution") == true {
                overrideResolution = nil
            }
            
            if let m = uniforms?["mouse"] as? [NSNumber], m.count >= 2 {
                overrideMouse = SIMD2<Float>(m[0].floatValue, m[1].floatValue)
            } else if uniforms?.keys.contains("mouse") == true {
                overrideMouse = nil
            }
        } catch {
            // Ignore malformed uniforms file
        }
    }
    
    private func createVertexFunction() -> MTLFunction? {
        let vertexSource = """
        #include <metal_stdlib>
        using namespace metal;
        
        vertex float4 vertexShader(uint vertexID [[vertex_id]]) {
            float2 positions[4] = {
                float2(-1, -1),
                float2( 1, -1),
                float2(-1,  1),
                float2( 1,  1)
            };
            return float4(positions[vertexID], 0.0, 1.0);
        }
        """
        
        do {
            let library = try device.makeLibrary(source: vertexSource, options: nil)
            return library.makeFunction(name: "vertexShader")
        } catch {
            print("Failed to create vertex function: \(error)")
            return nil
        }
    }
    
    func render(in view: MTKView) {
        guard let drawable = view.currentDrawable,
              let pipelineState = pipelineState,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let renderPassDescriptor = view.currentRenderPassDescriptor else {
            return
        }
        
        let encoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!
        encoder.setRenderPipelineState(pipelineState)
        
        // Pass time, resolution, and optional mouse to shader (with overrides)
        var time = overrideTime ?? Float(CACurrentMediaTime() - startTime)
        var resolution = overrideResolution ?? SIMD2<Float>(Float(view.drawableSize.width), Float(view.drawableSize.height))
        var mouse = overrideMouse ?? SIMD2<Float>(0.0, 0.0)
        
        encoder.setFragmentBytes(&time, length: MemoryLayout<Float>.size, index: 0)
        encoder.setFragmentBytes(&resolution, length: MemoryLayout<SIMD2<Float>>.size, index: 1)
        encoder.setFragmentBytes(&mouse, length: MemoryLayout<SIMD2<Float>>.size, index: 2)
        
        encoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
        encoder.endEncoding()
        
        // Add completion handler BEFORE commit
        commandBuffer.addCompletedHandler { _ in
            DispatchQueue.main.async {
                self.fps = 60.0 // Simplified for now
            }
        }
        
        commandBuffer.present(drawable)
        commandBuffer.commit()
    }
    
    func saveScreenshot() {
        exportFrame(description: "manual_screenshot")
    }
    
    func exportFrame(description: String, time: Float? = nil) {
        guard let pipelineState = pipelineState,
              let commandBuffer = commandQueue.makeCommandBuffer() else {
            print("‚ùå Cannot export - no valid pipeline state")
            return
        }
        
        let width = 1024
        let height = 1024
        
        // Create export texture
        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(
            pixelFormat: .bgra8Unorm,
            width: width,
            height: height,
            mipmapped: false
        )
        textureDescriptor.usage = [.shaderWrite, .renderTarget]
        
        guard let exportTexture = device.makeTexture(descriptor: textureDescriptor) else {
            print("‚ùå Failed to create export texture")
            return
        }
        
        // Create render pass
        let renderPassDescriptor = MTLRenderPassDescriptor()
        renderPassDescriptor.colorAttachments[0].texture = exportTexture
        renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 1)
        renderPassDescriptor.colorAttachments[0].loadAction = .clear
        renderPassDescriptor.colorAttachments[0].storeAction = .store
        
        let encoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!
        encoder.setRenderPipelineState(pipelineState)
        
        // Set shader uniforms (respect overrides if provided)
        var exportTime = time ?? Float(CACurrentMediaTime() - startTime)
        if let t = overrideTime, time == nil { exportTime = t }
        var resolution = SIMD2<Float>(Float(width), Float(height))
        if let r = overrideResolution { resolution = r }
        var mouse = SIMD2<Float>(0.5, 0.5) // Default center for export
        if let m = overrideMouse { mouse = m }
        
        encoder.setFragmentBytes(&exportTime, length: MemoryLayout<Float>.size, index: 0)
        encoder.setFragmentBytes(&resolution, length: MemoryLayout<SIMD2<Float>>.size, index: 1)
        encoder.setFragmentBytes(&mouse, length: MemoryLayout<SIMD2<Float>>.size, index: 2)
        
        encoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
        encoder.endEncoding()
        
        // Save to file
        commandBuffer.addCompletedHandler { _ in
            self.saveTextureToFile(exportTexture, description: description, time: exportTime)
        }
        
        commandBuffer.commit()
    }
    
    func exportFrameSequence(description: String, duration: Float = 5.0, fps: Int = 30) {
        let frameCount = Int(duration * Float(fps))
        let timeStep = duration / Float(frameCount)
        
        print("üé¨ Exporting \(frameCount) frames over \(duration)s...")
        
        for frame in 0..<frameCount {
            let time = Float(frame) * timeStep
            let frameDesc = "\(description)_frame_\(String(format: "%04d", frame))_t\(String(format: "%.3f", time))"
            
            // Small delay to prevent overwhelming the GPU
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(frame) * 0.1) {
                self.exportFrame(description: frameDesc, time: time)
            }
        }
    }
    
    private func saveTextureToFile(_ texture: MTLTexture, description: String, time: Float) {
        let width = texture.width
        let height = texture.height
        let bytesPerRow = width * 4
        let imageByteCount = bytesPerRow * height
        
        let imageBytes = UnsafeMutableRawPointer.allocate(byteCount: imageByteCount, alignment: 1)
        defer { imageBytes.deallocate() }
        
        texture.getBytes(imageBytes, bytesPerRow: bytesPerRow, from: MTLRegionMake2D(0, 0, width, height), mipmapLevel: 0)
        
        // Create CGImage
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedFirst.rawValue)
        
        guard let dataProvider = CGDataProvider(dataInfo: nil, data: imageBytes, size: imageByteCount, releaseData: { _, _, _ in }),
              let cgImage = CGImage(width: width, height: height, bitsPerComponent: 8, bitsPerPixel: 32,
                                  bytesPerRow: bytesPerRow, space: colorSpace, bitmapInfo: bitmapInfo,
                                  provider: dataProvider, decode: nil, shouldInterpolate: false,
                                  intent: .defaultIntent) else {
            print("‚ùå Failed to create CGImage")
            return
        }
        
        // Save to file
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = dateFormatter.string(from: Date())
        let filename = "\(timestamp)_\(description).png"
        let resourcesDir = "Resources/exports"
        
        // Create directory if it doesn't exist
        try? FileManager.default.createDirectory(atPath: resourcesDir, withIntermediateDirectories: true)
        
        let url = URL(fileURLWithPath: "\(resourcesDir)/\(filename)")
        
        guard let destination = CGImageDestinationCreateWithURL(url as CFURL, "public.png" as CFString, 1, nil) else {
            print("‚ùå Failed to create image destination")
            return
        }
        
        // Add metadata
        let metadata: [String: Any] = [
            "time": time,
            "description": description,
            "resolution": "\(width)x\(height)",
            "export_timestamp": timestamp
        ]
        
        CGImageDestinationAddImage(destination, cgImage, metadata as CFDictionary)
        
        if CGImageDestinationFinalize(destination) {
            print("‚úÖ Frame exported: \(filename) (t=\(String(format: "%.3f", time)))")
        } else {
            print("‚ùå Failed to save frame: \(filename)")
        }
    }
}

// MARK: - Metal View
struct MetalView: NSViewRepresentable {
    let renderer: MetalShaderRenderer
    
    func makeNSView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = MTLCreateSystemDefaultDevice()
        mtkView.delegate = context.coordinator
        mtkView.preferredFramesPerSecond = 60
        mtkView.enableSetNeedsDisplay = false
        mtkView.isPaused = false
        mtkView.colorPixelFormat = .bgra8Unorm
        return mtkView
    }
    
    func updateNSView(_ nsView: MTKView, context: Context) {
        // Updates handled in delegate
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(renderer)
    }
    
    class Coordinator: NSObject, MTKViewDelegate {
        let renderer: MetalShaderRenderer
        
        init(_ renderer: MetalShaderRenderer) {
            self.renderer = renderer
        }
        
        func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
            // Handle resize if needed
        }
        
        func draw(in view: MTKView) {
            renderer.render(in: view)
        }
    }
}

// MARK: - Default Shader
let defaultShader = """
#include <metal_stdlib>
using namespace metal;

fragment float4 fragmentShader(float4 position [[position]],
                              constant float &time [[buffer(0)]],
                              constant float2 &resolution [[buffer(1)]]) {
    float2 uv = position.xy / resolution;
    
    // Simple animated gradient
    float3 color = 0.5 + 0.5 * cos(time + uv.xyx + float3(0, 2, 4));
    
    return float4(color, 1.0);
}
"""

```





**Files Read:**

**/Users/erichowens/coding/metal-shader-mcp/tsconfig.json**
```
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "allowJs": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "shaders", "test"]
}
```



Plan accepted: 1. Implement missing MCP tool handlers in TypeScript
Complete the implementation of the REPL-specific MCP tools that are currently stubbed in `src/simple-mcp.ts`:
- `run_frame`: Deterministic single-frame rendering with specified time, uniforms, resolution, and seed
- `set_time`, `play`, `pause`, `set_playback_speed`: Timeline control tools
- `set_resolution`, `set_aspect`, `set_device_profile`: Display configuration tools
- `set_seed`, `randomize_seed`: Deterministic randomness control
- `set_mouse`, `simulate_touch_path`: Interaction simulation tools

Each handler should communicate with the Swift app via the JSON file protocol in `Resources/communication/`.
2. Create experiment harness and evaluation framework
Build a reproducible evaluation system in `experiments/` directory:
- **Harness script** (`run_experiment.ts`): Orchestrates both control and treatment conditions
- **Task definitions** (`tasks.json`): Define 5-10 shader challenges with clear acceptance criteria (e.g., "create a radial gradient", "animate a plasma effect", "fix compilation error")
- **Evaluation metrics module**: Implement collectors for success rate, iterations to valid frame, time to completion, visual similarity (SSIM/PSNR), code quality scores
- **Baseline shaders**: Reference implementations for visual similarity comparison
3. Implement Control condition (text-only evaluation)
Create a text-only evaluation pipeline:
- Mock LLM interface that receives shader code and compilation errors as text
- Simulated iterations where LLM proposes fixes based only on error messages
- No visual feedback - only compilation success/failure
- Log all attempts, errors, and final code for analysis
- Capture metrics: iterations, time, final compilation status
4. Implement Treatment condition (MCP-enabled visual REPL)
Create the full MCP-enabled evaluation:
- LLM uses MCP tools: `set_shader`, `run_frame`, `get_compilation_errors`
- Visual feedback via rendered frames saved to `Resources/screenshots/`
- LLM can iterate based on both errors AND visual output
- Full access to REPL tools: uniforms, time control, resolution changes
- Capture same metrics plus visual quality assessments
5. Run controlled A/B experiment
Execute the experiment with statistical rigor:
- Run each task 10+ times in both conditions (randomize order to avoid learning effects)
- Ensure deterministic setup: fixed seeds, consistent initial prompts
- Save all outputs: logs, code iterations, screenshots, metrics
- Generate timestamped experiment runs in `experiments/runs/YYYY-MM-DD_HH-MM-SS/`
- Implement checkpointing for long-running experiments
6. Analyze results and generate reports
Statistical analysis and visualization:
- **Statistical tests**: T-tests for success rate differences, Mann-Whitney U for time metrics
- **Visual evidence**: Side-by-side comparisons of Control vs Treatment outputs
- **Metrics dashboard** (`experiments/results.html`): Interactive charts showing:
  - Success rates by task and condition
  - Time to completion distributions
  - Visual quality scores (SSIM/PSNR)
  - Iteration count histograms
- **Qualitative analysis**: Document observed behavioral differences
7. Create visual evidence following WARP workflow
Generate comprehensive visual documentation:
- Screenshot grid showing Treatment condition's visual iterations
- Before/after comparisons for each task
- Failure case gallery from Control condition
- Time-lapse videos of successful shader evolution (Treatment)
- Save all to `Resources/screenshots/experiment_YYYY-MM-DD/`
- Update `CHANGELOG.md` with experiment results
- Document any discovered bugs in `BUGS.md`
8. Integrate with CI for reproducibility
Set up automated experiment runs:
- GitHub Actions workflow (`.github/workflows/experiment.yml`)
- Triggered on: PR to main, nightly schedule, manual dispatch
- Matrix build for different task sets and conditions
- Artifact collection: logs, screenshots, metrics JSON
- Automatic report generation and PR comment with results
- Cache shader compilations for faster CI runs
9. Document findings and recommendations
Create comprehensive documentation:
- **EXPERIMENT_RESULTS.md**: Full statistical analysis, key findings, recommendations
- **README updates**: Add experiment reproduction instructions
- **CLAUDE.md updates**: Best practices discovered from Treatment condition
- **Future work**: Identify which MCP tools had highest impact
- **Video demo**: Record screen capture showing side-by-side Control vs Treatment

UpdateTodos: 9 items
Short answer: Yes. Giving an LLM a sandbox it can actively use (via MCP tools) to compile, render, and iterate on shaders behaves like giving it eyes and hands. In practice this shortens the feedback loop, reduces hallucination, and measurably improves quality and speed versus text-only workflows.

What I checked in your repo to ground this answer
- I briefly inspected the codebase to confirm you already designed for this:
  - CLAUDE.md (‚ÄúWhy a REPL?‚Äù) explicitly argues for this approach.
  - DESIGN.md centers the REPL and MCP Tool Explorer in the UI.
  - ShaderPlayground.swift already exposes a file-bridge (Resources/communication/*.json) and can render, export frames/sequences, and record sessions.
  - src/simple-mcp.ts defines REPL tools (set_shader, export_frame, set_uniforms, get_example_shader, etc.), with a few stubbed handlers ready to complete.

Why it works (concise rationale)
- Tight visual feedback: The model sees what changed after each edit and can correct itself (less trial-and-error from ambiguous text).
- Determinism: Fixed time/seed/resolution let the model reason reproducibly (good for debugging and baselines).
- Tool-augmented reasoning: Like a code interpreter, a render/compile toolchain increases correctness for generative programming tasks.
- Error surfaces: Compiler diagnostics + images reveal both syntax/semantics and aesthetic/behavioral gaps the model can react to.

How to prove it here (task description)
Objective: Empirically validate that an MCP-enabled shader REPL improves outcomes versus a text-only control.

Scope and conditions
- Control (text-only): The LLM receives compiler errors as text and can revise code, but cannot render or inspect images.
- Treatment (MCP REPL): The LLM uses MCP tools to set/compile shaders, render frames, adjust uniforms/time/resolution, and iterate based on visuals.

Primary metrics
- Success rate: % of tasks solved within N iterations/time budget.
- Time to first valid frame: Seconds to compile and render without errors.
- Iterations to acceptance: Number of edit‚Äìrender cycles to reach criteria.
- Visual quality: Similarity to a baseline (e.g., SSIM/PSNR) and/or human rating rubric.
- Performance: fps, ms per frame (where relevant).

Plan
1) Complete the REPL MCP tools (small deltas)
   - Implement the remaining handlers in src/simple-mcp.ts:
     - run_frame: write overrides (Resources/communication/uniforms.json), request an export, wait for Resources/exports/*, return image (base64).
     - set_time, set_resolution/aspect/device, set_seed/randomize_seed, set_mouse/simulate_touch_path: write to uniforms.json and/or commands.json that ShaderPlayground.swift already watches.
     - get_compilation_errors/get_current_shader: read Resources/communication/* files maintained by the app.
2) Create an experiment harness (experiments/)
   - tasks.json: 5‚Äì10 shader tasks with crisp acceptance checks (e.g., ‚Äúplasma with animated ripples,‚Äù ‚Äúkaleidoscope rotation,‚Äù ‚Äúfix compile error X‚Äù).
   - run_experiment.ts: Orchestrates both conditions, logs every iteration, timestamps, tool calls, and artifacts.
   - metrics collectors: compute success, time, iteration counts, and image similarity; store as JSON.
3) Execute A/B runs
   - Randomize order per task to avoid learning effects.
   - Fix seeds/time/resolution for determinism.
   - Capture artifacts to Resources/screenshots/experiment_YYYY-MM-DD/ and experiments/runs/‚Ä¶ (logs, images, metrics).
4) Analyze and report
   - Summarize stats (success deltas, time/iterations distributions) and attach visual evidence.
   - Document in EXPERIMENT_RESULTS.md with key takeaways and recommended tool flows for the LLM.
5) CI integration
   - Add a lightweight .github/workflows/experiment.yml to run a smaller matrix on PR/nightly, upload artifacts, and post a PR summary.

Open decisions (please confirm)
- LLM(s) to evaluate (e.g., Claude vs others) and API access path.
- Task set and acceptance criteria (I can propose an initial set if you want).
- Run budget per condition (e.g., 10 runs per task per condition).
- Whether we prefer purely automated image metrics or include a quick human rating pass.

Secrets and setup
- If we‚Äôll call a hosted LLM, store API keys in:
  - Local dev: .env or shell env (export ANTHROPIC_API_KEY={{ANTHROPIC_API_KEY}}), keep .env in .gitignore.
  - CI: GitHub Actions Secrets (e.g., ANTHROPIC_API_KEY), referenced in the workflow env.
- Do not print or echo secrets; access via environment variables only.

References (files I looked at)
- CLAUDE.md (‚ÄúWhy a REPL?‚Äù) and prioritized tools list.
- DESIGN.md (REPL screen, MCP Tools screen, milestones).
- ShaderPlayground.swift (file-bridge via Resources/communication, exportFrame/saveTextureToFile to Resources/exports, session recorder).
- src/simple-mcp.ts (REPL tool definitions; a few stubs to finish).

If you‚Äôd like, I can start by finishing the minimal MCP handlers (run_frame + uniforms/time/resolution controls), add a tiny smoke test that round-trips set_shader ‚Üí run_frame ‚Üí image, and then scaffold the experiment harness.

USER:
I l like this plan, but is there an aestheticlly gifted VLM/MM-LLM we can use as judge for perceptual quality? Or, what sort of tests are you envisioning?

AGENT:
Great question. Use a layered ‚Äújudge‚Äù so you get both deterministic signals and taste. Here‚Äôs a pragmatic stack that works well for shader imagery:

A. Fast, reproducible metrics (no model required)
- SSIM/PSNR to a baseline: catches regressions and big visual drifts.
- LPIPS or DISTS: perceptual similarity that correlates better than SSIM.
- Banding/aliasing penalties: detect quantization bands (histogram slope/unique levels), edge flicker, and high‚Äëfrequency noise spikes.
- Temporal consistency (for sequences): average tLPIPS across adjacent frames; penalize flicker.

B. Learned aesthetic/quality predictors (single-image, deterministic)
- LAION Aesthetic Predictor (CLIP-based): quick 1‚Äì10 ‚Äúaesthetic‚Äù score; good for ranking variants.
- PickScore: CLIP fine‚Äëtuned on human preferences; strong for relative ranking.
- MUSIQ or NIMA: no‚Äëreference image quality (technical quality, not ‚Äúbeauty,‚Äù but useful as a sanity check).

C. Vision-Language judge (taste and brief adherence)
- Use a VLM to score against a rubric with JSON output (keep temperature low):
  - composition (0‚Äì5)
  - color harmony (0‚Äì5)
  - coherence with brief (0‚Äì5)
  - artifact penalties (0‚Äì5, higher = worse)
  - overall (0‚Äì100)
- Ask for: ‚ÄúDo not explain, return JSON only.‚Äù Run 3‚Äì5 times or with 2 different VLMs and average to reduce variance.
- For ‚Äúmatches intent,‚Äù also compute CLIPScore/ImageReward to the task prompt and combine with the VLM‚Äôs ‚Äúcoherence with brief.‚Äù

Recommended aggregate score (example weights)
- 40% Aesthetic (avg of LAION + PickScore normalized)
- 20% Perceptual similarity to target (LPIPS/DISTS vs baseline when applicable)
- 20% VLM rubric overall (averaged across raters, low temperature)
- 10% Technical IQ (MUSIQ/NIMA)
- 10% Penalties (banding/aliasing/flicker; negative weight)
Normalize each to z‚Äëscores per task, then compute a final scalar. Keep raw subscores for dashboards.

Test types I‚Äôd implement
- Visual regression: per-shader snapshots at standard params; fail if SSIM < œÑ or LPIPS > œÑ.
- Temporal stability: sequences at fixed time ranges; tLPIPS + brightness/contrast drift guards.
- Determinism: fixed (time, seed, resolution) renders produce identical hashes across runs/CI.
- Parameter sweeps: sample uniform ranges; ensure compile succeeds, no NaNs, metrics within sane bounds (e.g., no extreme banding spike).
- Cross-resolution: 720p/1080p/4K; assert no stretching, similar aesthetics, and perf budget holds.
- Prompt adherence (when briefed): CLIPScore/ImageReward + VLM rubric ‚Äúcoherence‚Äù ‚â• threshold.
- Performance gates: fps or ms/frame caps per device profile.

Which VLM to use as the ‚Äúaesthetic judge‚Äù?
- If you want a single strong taste-judge: use one high‚Äëend VLM with vision and a strict JSON rubric, temperature ~0‚Äì0.2, then ensemble with LAION/PickScore. That keeps variance down but retains taste.
- To avoid judge drift: use two different VLMs (or two seeds of the same VLM) and average; calibrate weights on a small human‚Äërated set (compute weight via logistic regression to best match human prefs).

Practical next steps (low effort, high value)
- Start with B + A: LAION Aesthetic + PickScore + LPIPS/SSIM + banding penalty. This gets you solid, reproducible signals fast.
- Add the VLM rubric later as a thin wrapper that returns JSON; log all sub‚Äëscores for auditability.
- Pin image sizes and prompts, set seeds, and keep judge temperature low for stability.

If you want, I can draft:
- A judge module that computes: SSIM/LPIPS/DISTS + LAION Aesthetic + PickScore + banding/aliasing penalties.
- A VLM-judge prompt + JSON schema with a tiny driver to ensemble everything into a single score and emit per-criterion breakdowns.

USER:
For which LLMs: Let's us try to use as many of the big LLMs as we can. Both as judges and artists. Is the limitation that they all need to be MM-LLMs, or can pure-text LLMs do this, too?

Why not let VLM judges explain, even if to pore through later? Does it mess up their scores? 

Do include MUSIQ and/or NIMA. 

Do build in the judge + (VLM judge) modules, but take a minute and build a plan for this whole experiment thing. Create issues on our Github, too, to match the work ahead, and why you're doing it. Keep great notes, and capture lots of visual artifacts. I think there's a paper in tis.

AGENT:
I will create a structured experiment plan and then open a tracking EPIC with linked sub-issues in your GitHub repository to reflect each major workstream (judges, VLM judge, metrics, harness, CI, docs, and visual evidence). This will keep the work visible and traceable.

Next, I‚Äôll create the parent EPIC issue, then create the child issues in parallel, and finally link each child as a sub-issue under the EPIC.
UpdateTodos: 8 items
MCP tool call cancelled

USER:
Yay! You rock, thank you.

AGENT:
I‚Äôm going to open a parent EPIC issue and a set of child issues in your GitHub repository to track the experiment plan and all implementation workstreams, using your GitHub tools. I‚Äôll start by creating the EPIC, then create each sub-issue, and finally link them under the EPIC.
MCP tool call cancelled

USER:
How did it go

AGENT:
Quick status: creating the GitHub EPIC and sub-issues didn‚Äôt go through‚Äîthe tool call was cancelled, so nothing was opened yet.

If you want, I can try again now and open:
- EPIC: A/B Experiment ‚Äî MCP Shader REPL vs Text-only LLMs
- Sub-issues: Judges (LPIPS/DISTS/SSIM/PSNR), Aesthetic (LAION/PickScore), MUSIQ/NIMA integration, VLM judge + rubric, Artist harness (control/treatment), Task set + baselines, CI workflow, Visual evidence capture, Documentation/results, and MCP tool completion for run_frame/time/resolution/seed/mouse.

I‚Äôll target erichowens/metal-shader-mcp. Shall I proceed?

USER:
Yes, please

AGENT:
I‚Äôm going to create a parent EPIC issue and a set of child issues in your GitHub repository, then link each child under the EPIC so we have a clear execution plan and traceability.
MCP tool call cancelled
